{
  "version": 3,
  "sources": ["../../@pixiv/three-vrm-animation/src/createVRMAnimationClip.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpression.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/utils/gltfExtractPrimitivesFromNode.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionPresetName.ts", "../../@pixiv/three-vrm-core/src/utils/saturate.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionManager.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionMaterialColorType.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionMaterialColorBind.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionMorphTargetBind.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionTextureTransformBind.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionOverrideType.ts", "../../@pixiv/three-vrm-core/src/firstPerson/VRMFirstPerson.ts", "../../@pixiv/three-vrm-core/src/firstPerson/VRMFirstPersonLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/firstPerson/VRMFirstPersonMeshAnnotationType.ts", "../../@pixiv/three-vrm-core/src/humanoid/helpers/VRMHumanoidHelper.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanBoneList.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanBoneName.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanBoneParentMap.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMRig.ts", "../../@pixiv/three-vrm-core/src/utils/quatInvertCompat.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanoidRig.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanoid.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMRequiredHumanBoneName.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanoidLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/lookAt/helpers/VRMLookAtHelper.ts", "../../@pixiv/three-vrm-core/src/lookAt/helpers/utils/FanBufferGeometry.ts", "../../@pixiv/three-vrm-core/src/lookAt/helpers/utils/LineAndSphereBufferGeometry.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAt.ts", "../../@pixiv/three-vrm-core/src/utils/getWorldQuaternionLite.ts", "../../@pixiv/three-vrm-core/src/lookAt/utils/calcAzimuthAltitude.ts", "../../@pixiv/three-vrm-core/src/lookAt/utils/sanitizeAngle.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtBoneApplier.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtExpressionApplier.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtRangeMap.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtTypeName.ts", "../../@pixiv/three-vrm-core/src/meta/VRMMetaLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/utils/resolveURL.ts", "../../@pixiv/three-vrm-core/src/VRMCore.ts", "../../@pixiv/three-vrm-core/src/VRMCoreLoaderPlugin.ts", "../../@pixiv/three-vrm-animation/src/VRMLookAtQuaternionProxy.ts", "../../@pixiv/three-vrm-animation/src/VRMAnimation.ts", "../../@pixiv/three-vrm-animation/src/VRMAnimationLoaderPlugin.ts", "../../@pixiv/three-vrm-animation/src/utils/arrayChunk.ts"],
  "sourcesContent": ["import * as THREE from 'three';\nimport type {\n  VRMCore,\n  VRMExpressionManager,\n  VRMExpressionPresetName,\n  VRMHumanBoneName,\n  VRMHumanoid,\n} from '@pixiv/three-vrm-core';\nimport type { VRMAnimation } from './VRMAnimation';\nimport { VRMLookAtQuaternionProxy } from './VRMLookAtQuaternionProxy';\n\nexport function createVRMAnimationHumanoidTracks(\n  vrmAnimation: VRMAnimation,\n  humanoid: VRMHumanoid,\n  metaVersion: '0' | '1',\n): {\n  translation: Map<'hips', THREE.VectorKeyframeTrack>;\n  rotation: Map<VRMHumanBoneName, THREE.QuaternionKeyframeTrack>;\n} {\n  const translation = new Map<'hips', THREE.VectorKeyframeTrack>();\n  const rotation = new Map<VRMHumanBoneName, THREE.VectorKeyframeTrack>();\n\n  for (const [name, origTrack] of vrmAnimation.humanoidTracks.rotation.entries()) {\n    const nodeName = humanoid.getNormalizedBoneNode(name)?.name;\n\n    if (nodeName != null) {\n      const track = new THREE.QuaternionKeyframeTrack(\n        `${nodeName}.quaternion`,\n        origTrack.times,\n        origTrack.values.map((v, i) => (metaVersion === '0' && i % 2 === 0 ? -v : v)),\n      );\n      rotation.set(name, track);\n    }\n  }\n\n  for (const [name, origTrack] of vrmAnimation.humanoidTracks.translation.entries()) {\n    const nodeName = humanoid.getNormalizedBoneNode(name)?.name;\n\n    if (nodeName != null) {\n      const animationY = vrmAnimation.restHipsPosition.y;\n      const humanoidY = humanoid.normalizedRestPose.hips!.position![1];\n      const scale = humanoidY / animationY;\n\n      const track = origTrack.clone();\n      track.values = track.values.map((v, i) => (metaVersion === '0' && i % 3 !== 1 ? -v : v) * scale);\n      track.name = `${nodeName}.position`;\n      translation.set(name, track);\n    }\n  }\n\n  return { translation, rotation };\n}\n\nexport function createVRMAnimationExpressionTracks(\n  vrmAnimation: VRMAnimation,\n  expressionManager: VRMExpressionManager,\n): {\n  preset: Map<VRMExpressionPresetName, THREE.NumberKeyframeTrack>;\n  custom: Map<string, THREE.NumberKeyframeTrack>;\n} {\n  const preset = new Map<VRMExpressionPresetName, THREE.NumberKeyframeTrack>();\n  const custom = new Map<string, THREE.NumberKeyframeTrack>();\n\n  for (const [name, origTrack] of vrmAnimation.expressionTracks.preset.entries()) {\n    const trackName = expressionManager.getExpressionTrackName(name);\n\n    if (trackName != null) {\n      const track = origTrack.clone();\n      track.name = trackName;\n      preset.set(name, track);\n    }\n  }\n\n  for (const [name, origTrack] of vrmAnimation.expressionTracks.custom.entries()) {\n    const trackName = expressionManager.getExpressionTrackName(name);\n\n    if (trackName != null) {\n      const track = origTrack.clone();\n      track.name = trackName;\n      custom.set(name, track);\n    }\n  }\n\n  return { preset, custom };\n}\n\nexport function createVRMAnimationLookAtTrack(\n  vrmAnimation: VRMAnimation,\n  trackName: string,\n): THREE.KeyframeTrack | null {\n  if (vrmAnimation.lookAtTrack == null) {\n    return null;\n  }\n\n  const track = vrmAnimation.lookAtTrack.clone();\n  track.name = trackName;\n  return track;\n}\n\n/**\n * Create an AnimationClip out of the given VRMAnimation and the VRM.\n *\n * @param vrmAnimation A {@link VRMAnimation}.\n * @param vrm A {@link VRMCore}.\n * @returns An AnimationClip\n */\nexport function createVRMAnimationClip(vrmAnimation: VRMAnimation, vrm: VRMCore): THREE.AnimationClip {\n  const tracks: THREE.KeyframeTrack[] = [];\n\n  const humanoidTracks = createVRMAnimationHumanoidTracks(vrmAnimation, vrm.humanoid, vrm.meta.metaVersion);\n  tracks.push(...humanoidTracks.translation.values());\n  tracks.push(...humanoidTracks.rotation.values());\n\n  if (vrm.expressionManager != null) {\n    const expressionTracks = createVRMAnimationExpressionTracks(vrmAnimation, vrm.expressionManager);\n    tracks.push(...expressionTracks.preset.values());\n    tracks.push(...expressionTracks.custom.values());\n  }\n\n  if (vrm.lookAt != null) {\n    // search VRMLookAtQuaternionProxy\n    let proxy = vrm.scene.children.find((obj) => obj instanceof VRMLookAtQuaternionProxy);\n\n    if (proxy == null) {\n      // if not found, create a new one\n      console.warn(\n        'createVRMAnimationClip: VRMLookAtQuaternionProxy is not found. Creating a new one automatically. To suppress this warning, create a VRMLookAtQuaternionProxy manually',\n      );\n\n      proxy = new VRMLookAtQuaternionProxy(vrm.lookAt);\n      proxy.name = 'VRMLookAtQuaternionProxy';\n      vrm.scene.add(proxy);\n    } else if (proxy.name === '') {\n      // if found but name is not set, set the name automatically\n      console.warn(\n        'createVRMAnimationClip: VRMLookAtQuaternionProxy is found but its name is not set. Setting the name automatically. To suppress this warning, set the name manually',\n      );\n\n      proxy.name = 'VRMLookAtQuaternionProxy';\n    }\n\n    // create a track\n    const track = createVRMAnimationLookAtTrack(vrmAnimation, `${proxy.name}.quaternion`);\n    if (track != null) {\n      tracks.push(track);\n    }\n  }\n\n  return new THREE.AnimationClip('Clip', vrmAnimation.duration, tracks);\n}\n", "import * as THREE from 'three';\nimport { VRMExpressionBind } from './VRMExpressionBind';\nimport type { VRMExpressionOverrideType } from './VRMExpressionOverrideType';\nimport type { VRMExpressionManager } from './VRMExpressionManager';\n\n// animationMixer \u306E\u76E3\u8996\u5BFE\u8C61\u306F\u3001Scene \u306E\u4E2D\u306B\u5165\u3063\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308B\u3002\n// \u305D\u306E\u305F\u3081\u3001\u8868\u793A\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3067\u306F\u306A\u3044\u3051\u308C\u3069\u3001Object3D \u3092\u7D99\u627F\u3057\u3066 Scene \u306B\u6295\u5165\u3067\u304D\u308B\u3088\u3046\u306B\u3059\u308B\u3002\nexport class VRMExpression extends THREE.Object3D {\n  /**\n   * Name of this expression.\n   * Distinguished with `name` since `name` will be conflicted with Object3D.\n   */\n  public expressionName: string;\n\n  /**\n   * The current weight of the expression.\n   *\n   * You usually want to set the weight via {@link VRMExpressionManager.setValue}.\n   *\n   * It might also be controlled by the Three.js animation system.\n   */\n  public weight = 0.0;\n\n  /**\n   * Interpret values greater than 0.5 as 1.0, ortherwise 0.0.\n   */\n  public isBinary = false;\n\n  /**\n   * Specify how the expression overrides blink expressions.\n   */\n  public overrideBlink: VRMExpressionOverrideType = 'none';\n\n  /**\n   * Specify how the expression overrides lookAt expressions.\n   */\n  public overrideLookAt: VRMExpressionOverrideType = 'none';\n\n  /**\n   * Specify how the expression overrides mouth expressions.\n   */\n  public overrideMouth: VRMExpressionOverrideType = 'none';\n\n  /**\n   * Binds that this expression influences.\n   */\n  private _binds: VRMExpressionBind[] = [];\n\n  /**\n   * Binds that this expression influences.\n   */\n  public get binds(): readonly VRMExpressionBind[] {\n    return this._binds;\n  }\n\n  override readonly type: string | 'VRMExpression';\n\n  /**\n   * A value represents how much it should override blink expressions.\n   * `0.0` == no override at all, `1.0` == completely block the expressions.\n   */\n  public get overrideBlinkAmount(): number {\n    if (this.overrideBlink === 'block') {\n      return 0.0 < this.outputWeight ? 1.0 : 0.0;\n    } else if (this.overrideBlink === 'blend') {\n      return this.outputWeight;\n    } else {\n      return 0.0;\n    }\n  }\n\n  /**\n   * A value represents how much it should override lookAt expressions.\n   * `0.0` == no override at all, `1.0` == completely block the expressions.\n   */\n  public get overrideLookAtAmount(): number {\n    if (this.overrideLookAt === 'block') {\n      return 0.0 < this.outputWeight ? 1.0 : 0.0;\n    } else if (this.overrideLookAt === 'blend') {\n      return this.outputWeight;\n    } else {\n      return 0.0;\n    }\n  }\n\n  /**\n   * A value represents how much it should override mouth expressions.\n   * `0.0` == no override at all, `1.0` == completely block the expressions.\n   */\n  public get overrideMouthAmount(): number {\n    if (this.overrideMouth === 'block') {\n      return 0.0 < this.outputWeight ? 1.0 : 0.0;\n    } else if (this.overrideMouth === 'blend') {\n      return this.outputWeight;\n    } else {\n      return 0.0;\n    }\n  }\n\n  /**\n   * An output weight of this expression, considering the {@link isBinary}.\n   */\n  public get outputWeight(): number {\n    if (this.isBinary) {\n      return this.weight > 0.5 ? 1.0 : 0.0;\n    }\n\n    return this.weight;\n  }\n\n  constructor(expressionName: string) {\n    super();\n\n    this.name = `VRMExpression_${expressionName}`;\n    this.expressionName = expressionName;\n\n    // traverse \u6642\u306E\u6551\u6E08\u624B\u6BB5\u3068\u3057\u3066 Object3D \u3067\u306F\u306A\u3044\u3053\u3068\u3092\u660E\u793A\u3057\u3066\u304A\u304F\n    this.type = 'VRMExpression';\n\n    // \u8868\u793A\u76EE\u7684\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3067\u306F\u306A\u3044\u306E\u3067\u3001\u8CA0\u8377\u8EFD\u6E1B\u306E\u305F\u3081\u306B visible \u3092 false \u306B\u3057\u3066\u304A\u304F\u3002\n    // \u3053\u308C\u306B\u3088\u308A\u3001\u3053\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u306B\u5BFE\u3059\u308B\u6BCE\u30D5\u30EC\u30FC\u30E0\u306E matrix \u81EA\u52D5\u8A08\u7B97\u3092\u7701\u7565\u3067\u304D\u308B\u3002\n    this.visible = false;\n  }\n\n  /**\n   * Add an expression bind to the expression.\n   *\n   * @param bind A bind to add\n   */\n  public addBind(bind: VRMExpressionBind): void {\n    this._binds.push(bind);\n  }\n\n  /**\n   * Delete an expression bind from the expression.\n   *\n   * @param bind A bind to delete\n   */\n  public deleteBind(bind: VRMExpressionBind): void {\n    const index = this._binds.indexOf(bind);\n    if (index >= 0) {\n      this._binds.splice(index, 1);\n    }\n  }\n\n  /**\n   * Apply weight to every assigned blend shapes.\n   * Should be called every frame.\n   */\n  public applyWeight(options?: {\n    /**\n     * Multiplies a value to its weight to apply.\n     * Intended to be used for overriding an expression weight by another expression.\n     * See also: {@link overrideBlink}, {@link overrideLookAt}, {@link overrideMouth}\n     */\n    multiplier?: number;\n  }): void {\n    let actualWeight = this.outputWeight;\n    actualWeight *= options?.multiplier ?? 1.0;\n\n    // if the expression is binary, the override value must be also treated as binary\n    if (this.isBinary && actualWeight < 1.0) {\n      actualWeight = 0.0;\n    }\n\n    this._binds.forEach((bind) => bind.applyWeight(actualWeight));\n  }\n\n  /**\n   * Clear previously assigned blend shapes.\n   */\n  public clearAppliedWeight(): void {\n    this._binds.forEach((bind) => bind.clearAppliedWeight());\n  }\n}\n", "import type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport * as THREE from 'three';\nimport { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { gltfExtractPrimitivesFromNode } from '../utils/gltfExtractPrimitivesFromNode';\nimport { VRMExpression } from './VRMExpression';\nimport { VRMExpressionManager } from './VRMExpressionManager';\nimport { v0ExpressionMaterialColorMap } from './VRMExpressionMaterialColorType';\nimport { VRMExpressionMaterialColorBind } from './VRMExpressionMaterialColorBind';\nimport { VRMExpressionMorphTargetBind } from './VRMExpressionMorphTargetBind';\nimport { VRMExpressionPresetName } from './VRMExpressionPresetName';\nimport { VRMExpressionTextureTransformBind } from './VRMExpressionTextureTransformBind';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRMExpressionManager} from a VRM extension of a GLTF.\n */\nexport class VRMExpressionLoaderPlugin implements GLTFLoaderPlugin {\n  public static readonly v0v1PresetNameMap: { [v0Name in V0VRM.BlendShapePresetName]?: VRMExpressionPresetName } = {\n    a: 'aa',\n    e: 'ee',\n    i: 'ih',\n    o: 'oh',\n    u: 'ou',\n    blink: 'blink',\n    joy: 'happy',\n    angry: 'angry',\n    sorrow: 'sad',\n    fun: 'relaxed',\n    lookup: 'lookUp',\n    lookdown: 'lookDown',\n    lookleft: 'lookLeft',\n    lookright: 'lookRight',\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    blink_l: 'blinkLeft',\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    blink_r: 'blinkRight',\n    neutral: 'neutral',\n  };\n\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMExpressionLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser) {\n    this.parser = parser;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    gltf.userData.vrmExpressionManager = await this._import(gltf);\n  }\n\n  /**\n   * Import a {@link VRMExpressionManager} from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  private async _import(gltf: GLTF): Promise<VRMExpressionManager | null> {\n    const v1Result = await this._v1Import(gltf);\n    if (v1Result) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf);\n    if (v0Result) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(gltf: GLTF): Promise<VRMExpressionManager | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (!extension) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaExpressions = extension.expressions;\n    if (!schemaExpressions) {\n      return null;\n    }\n\n    // list expressions\n    const presetNameSet = new Set<string>(Object.values(VRMExpressionPresetName));\n    const nameSchemaExpressionMap = new Map<string, V1VRMSchema.Expression>();\n\n    if (schemaExpressions.preset != null) {\n      Object.entries(schemaExpressions.preset).forEach(([name, schemaExpression]) => {\n        if (schemaExpression == null) {\n          return;\n        } // typescript\n\n        if (!presetNameSet.has(name)) {\n          console.warn(`VRMExpressionLoaderPlugin: Unknown preset name \"${name}\" detected. Ignoring the expression`);\n          return;\n        }\n\n        nameSchemaExpressionMap.set(name, schemaExpression);\n      });\n    }\n\n    if (schemaExpressions.custom != null) {\n      Object.entries(schemaExpressions.custom).forEach(([name, schemaExpression]) => {\n        if (presetNameSet.has(name)) {\n          console.warn(\n            `VRMExpressionLoaderPlugin: Custom expression cannot have preset name \"${name}\". Ignoring the expression`,\n          );\n          return;\n        }\n\n        nameSchemaExpressionMap.set(name, schemaExpression);\n      });\n    }\n\n    // prepare manager\n    const manager = new VRMExpressionManager();\n\n    // load expressions\n    await Promise.all(\n      Array.from(nameSchemaExpressionMap.entries()).map(async ([name, schemaExpression]) => {\n        const expression = new VRMExpression(name);\n        gltf.scene.add(expression);\n\n        expression.isBinary = schemaExpression.isBinary ?? false;\n        expression.overrideBlink = schemaExpression.overrideBlink ?? 'none';\n        expression.overrideLookAt = schemaExpression.overrideLookAt ?? 'none';\n        expression.overrideMouth = schemaExpression.overrideMouth ?? 'none';\n\n        schemaExpression.morphTargetBinds?.forEach(async (bind) => {\n          if (bind.node === undefined || bind.index === undefined) {\n            return;\n          }\n\n          const primitives = (await gltfExtractPrimitivesFromNode(gltf, bind.node))!;\n          const morphTargetIndex = bind.index;\n\n          // check if the mesh has the target morph target\n          if (\n            !primitives.every(\n              (primitive) =>\n                Array.isArray(primitive.morphTargetInfluences) &&\n                morphTargetIndex < primitive.morphTargetInfluences.length,\n            )\n          ) {\n            console.warn(\n              `VRMExpressionLoaderPlugin: ${schemaExpression.name} attempts to index morph #${morphTargetIndex} but not found.`,\n            );\n            return;\n          }\n\n          expression.addBind(\n            new VRMExpressionMorphTargetBind({\n              primitives,\n              index: morphTargetIndex,\n              weight: bind.weight ?? 1.0,\n            }),\n          );\n        });\n\n        if (schemaExpression.materialColorBinds || schemaExpression.textureTransformBinds) {\n          // list up every material in `gltf.scene`\n          const gltfMaterials: THREE.Material[] = [];\n          gltf.scene.traverse((object) => {\n            const material = (object as any).material as THREE.Material | THREE.Material[] | undefined;\n            if (material) {\n              if (Array.isArray(material)) {\n                gltfMaterials.push(...material);\n              } else {\n                gltfMaterials.push(material);\n              }\n            }\n          });\n\n          schemaExpression.materialColorBinds?.forEach(async (bind) => {\n            const materials = gltfMaterials.filter((material) => {\n              const materialIndex = this.parser.associations.get(material)?.materials;\n              return bind.material === materialIndex;\n            });\n\n            materials.forEach((material) => {\n              expression.addBind(\n                new VRMExpressionMaterialColorBind({\n                  material,\n                  type: bind.type,\n                  targetValue: new THREE.Color().fromArray(bind.targetValue),\n                  targetAlpha: bind.targetValue[3],\n                }),\n              );\n            });\n          });\n\n          schemaExpression.textureTransformBinds?.forEach(async (bind) => {\n            const materials = gltfMaterials.filter((material) => {\n              const materialIndex = this.parser.associations.get(material)?.materials;\n              return bind.material === materialIndex;\n            });\n\n            materials.forEach((material) => {\n              expression.addBind(\n                new VRMExpressionTextureTransformBind({\n                  material,\n                  offset: new THREE.Vector2().fromArray(bind.offset ?? [0.0, 0.0]),\n                  scale: new THREE.Vector2().fromArray(bind.scale ?? [1.0, 1.0]),\n                }),\n              );\n            });\n          });\n        }\n\n        manager.registerExpression(expression);\n      }),\n    );\n\n    return manager;\n  }\n\n  private async _v0Import(gltf: GLTF): Promise<VRMExpressionManager | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaBlendShape = vrmExt.blendShapeMaster;\n    if (!schemaBlendShape) {\n      return null;\n    }\n\n    const manager = new VRMExpressionManager();\n\n    const schemaBlendShapeGroups = schemaBlendShape.blendShapeGroups;\n    if (!schemaBlendShapeGroups) {\n      return manager;\n    }\n\n    const blendShapeNameSet = new Set<string>();\n\n    await Promise.all(\n      schemaBlendShapeGroups.map(async (schemaGroup) => {\n        const v0PresetName = schemaGroup.presetName;\n        const v1PresetName =\n          (v0PresetName != null && VRMExpressionLoaderPlugin.v0v1PresetNameMap[v0PresetName]) || null;\n        const name = v1PresetName ?? schemaGroup.name;\n\n        if (name == null) {\n          console.warn('VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression');\n          return;\n        }\n\n        // duplication check\n        if (blendShapeNameSet.has(name)) {\n          console.warn(\n            `VRMExpressionLoaderPlugin: An expression preset ${v0PresetName} has duplicated entries. Ignoring the expression`,\n          );\n          return;\n        }\n\n        blendShapeNameSet.add(name);\n\n        const expression = new VRMExpression(name);\n        gltf.scene.add(expression);\n\n        expression.isBinary = schemaGroup.isBinary ?? false;\n        // v0 doesn't have ignore properties\n\n        // Bind morphTarget\n        if (schemaGroup.binds) {\n          schemaGroup.binds.forEach(async (bind) => {\n            if (bind.mesh === undefined || bind.index === undefined) {\n              return;\n            }\n\n            const nodesUsingMesh: number[] = [];\n            json.nodes?.forEach((node, i) => {\n              if (node.mesh === bind.mesh) {\n                nodesUsingMesh.push(i);\n              }\n            });\n\n            const morphTargetIndex = bind.index;\n\n            await Promise.all(\n              nodesUsingMesh.map(async (nodeIndex) => {\n                const primitives = (await gltfExtractPrimitivesFromNode(gltf, nodeIndex))!;\n\n                // check if the mesh has the target morph target\n                if (\n                  !primitives.every(\n                    (primitive) =>\n                      Array.isArray(primitive.morphTargetInfluences) &&\n                      morphTargetIndex < primitive.morphTargetInfluences.length,\n                  )\n                ) {\n                  console.warn(\n                    `VRMExpressionLoaderPlugin: ${schemaGroup.name} attempts to index ${morphTargetIndex}th morph but not found.`,\n                  );\n                  return;\n                }\n\n                expression.addBind(\n                  new VRMExpressionMorphTargetBind({\n                    primitives,\n                    index: morphTargetIndex,\n                    weight: 0.01 * (bind.weight ?? 100), // narrowing the range from [ 0.0 - 100.0 ] to [ 0.0 - 1.0 ]\n                  }),\n                );\n              }),\n            );\n          });\n        }\n\n        // Bind MaterialColor and TextureTransform\n        const materialValues = schemaGroup.materialValues;\n        if (materialValues && materialValues.length !== 0) {\n          materialValues.forEach((materialValue) => {\n            if (\n              materialValue.materialName === undefined ||\n              materialValue.propertyName === undefined ||\n              materialValue.targetValue === undefined\n            ) {\n              return;\n            }\n\n            /**\n             * \u30A2\u30D0\u30BF\u30FC\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u306B\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u308B\u30DE\u30C6\u30EA\u30A2\u30EB\u306E\u5185\u304B\u3089\n             * materialValue\u3067\u6307\u5B9A\u3055\u308C\u3066\u3044\u308B\u30DE\u30C6\u30EA\u30A2\u30EB\u3092\u96C6\u3081\u308B\u3002\n             *\n             * \u7279\u5B9A\u306B\u306F\u540D\u524D\u3092\u4F7F\u7528\u3059\u308B\u3002\n             * \u30A2\u30A6\u30C8\u30E9\u30A4\u30F3\u63CF\u753B\u7528\u306E\u30DE\u30C6\u30EA\u30A2\u30EB\u3082\u540C\u6642\u306B\u96C6\u3081\u308B\u3002\n             */\n            const materials: THREE.Material[] = [];\n            gltf.scene.traverse((object) => {\n              if ((object as any).material) {\n                const material: THREE.Material[] | THREE.Material = (object as any).material;\n                if (Array.isArray(material)) {\n                  materials.push(\n                    ...material.filter(\n                      (mtl) =>\n                        (mtl.name === materialValue.materialName! ||\n                          mtl.name === materialValue.materialName! + ' (Outline)') &&\n                        materials.indexOf(mtl) === -1,\n                    ),\n                  );\n                } else if (material.name === materialValue.materialName && materials.indexOf(material) === -1) {\n                  materials.push(material);\n                }\n              }\n            });\n\n            const materialPropertyName = materialValue.propertyName;\n            materials.forEach((material) => {\n              // TextureTransformBind\n              if (materialPropertyName === '_MainTex_ST') {\n                const scale = new THREE.Vector2(materialValue.targetValue![0], materialValue.targetValue![1]);\n                const offset = new THREE.Vector2(materialValue.targetValue![2], materialValue.targetValue![3]);\n\n                offset.y = 1.0 - offset.y - scale.y;\n\n                expression.addBind(\n                  new VRMExpressionTextureTransformBind({\n                    material,\n                    scale,\n                    offset,\n                  }),\n                );\n\n                return;\n              }\n\n              // MaterialColorBind\n              const materialColorType = v0ExpressionMaterialColorMap[materialPropertyName];\n              if (materialColorType) {\n                expression.addBind(\n                  new VRMExpressionMaterialColorBind({\n                    material,\n                    type: materialColorType,\n                    targetValue: new THREE.Color().fromArray(materialValue.targetValue!),\n                    targetAlpha: materialValue.targetValue![3],\n                  }),\n                );\n\n                return;\n              }\n\n              console.warn(materialPropertyName + ' is not supported');\n            });\n          });\n        }\n\n        manager.registerExpression(expression);\n      }),\n    );\n\n    return manager;\n  }\n}\n", "import type * as THREE from 'three';\nimport type { GLTF } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\nfunction extractPrimitivesInternal(gltf: GLTF, nodeIndex: number, node: THREE.Object3D): THREE.Mesh[] | null {\n  const json = gltf.parser.json as GLTFSchema.IGLTF;\n\n  /**\n   * Let's list up every possible patterns that parsed gltf nodes with a mesh can have,,,\n   *\n   * \"*\" indicates that those meshes should be listed up using this function\n   *\n   * ### A node with a (mesh, a signle primitive)\n   *\n   * - `THREE.Mesh`: The only primitive of the mesh *\n   *\n   * ### A node with a (mesh, multiple primitives)\n   *\n   * - `THREE.Group`: The root of the mesh\n   *   - `THREE.Mesh`: A primitive of the mesh *\n   *   - `THREE.Mesh`: A primitive of the mesh (2) *\n   *\n   * ### A node with a (mesh, multiple primitives) AND (a child with a mesh, a single primitive)\n   *\n   * - `THREE.Group`: The root of the mesh\n   *   - `THREE.Mesh`: A primitive of the mesh *\n   *   - `THREE.Mesh`: A primitive of the mesh (2) *\n   *   - `THREE.Mesh`: A primitive of a MESH OF THE CHILD\n   *\n   * ### A node with a (mesh, multiple primitives) AND (a child with a mesh, multiple primitives)\n   *\n   * - `THREE.Group`: The root of the mesh\n   *   - `THREE.Mesh`: A primitive of the mesh *\n   *   - `THREE.Mesh`: A primitive of the mesh (2) *\n   *   - `THREE.Group`: The root of a MESH OF THE CHILD\n   *     - `THREE.Mesh`: A primitive of the mesh of the child\n   *     - `THREE.Mesh`: A primitive of the mesh of the child (2)\n   *\n   * ### A node with a (mesh, multiple primitives) BUT the node is a bone\n   *\n   * - `THREE.Bone`: The root of the node, as a bone\n   *   - `THREE.Group`: The root of the mesh\n   *     - `THREE.Mesh`: A primitive of the mesh *\n   *     - `THREE.Mesh`: A primitive of the mesh (2) *\n   *\n   * ### A node with a (mesh, multiple primitives) AND (a child with a mesh, multiple primitives) BUT the node is a bone\n   *\n   * - `THREE.Bone`: The root of the node, as a bone\n   *   - `THREE.Group`: The root of the mesh\n   *     - `THREE.Mesh`: A primitive of the mesh *\n   *     - `THREE.Mesh`: A primitive of the mesh (2) *\n   *   - `THREE.Group`: The root of a MESH OF THE CHILD\n   *     - `THREE.Mesh`: A primitive of the mesh of the child\n   *     - `THREE.Mesh`: A primitive of the mesh of the child (2)\n   *\n   * ...I will take a strategy that traverses the root of the node and take first (primitiveCount) meshes.\n   */\n\n  // Make sure that the node has a mesh\n  const schemaNode = json.nodes?.[nodeIndex];\n  if (schemaNode == null) {\n    console.warn(`extractPrimitivesInternal: Attempt to use nodes[${nodeIndex}] of glTF but the node doesn't exist`);\n    return null;\n  }\n\n  const meshIndex = schemaNode.mesh;\n  if (meshIndex == null) {\n    return null;\n  }\n\n  // How many primitives the mesh has?\n  const schemaMesh = json.meshes?.[meshIndex];\n  if (schemaMesh == null) {\n    console.warn(`extractPrimitivesInternal: Attempt to use meshes[${meshIndex}] of glTF but the mesh doesn't exist`);\n    return null;\n  }\n\n  const primitiveCount = schemaMesh.primitives.length;\n\n  // Traverse the node and take first (primitiveCount) meshes\n  const primitives: THREE.Mesh[] = [];\n  node.traverse((object) => {\n    if (primitives.length < primitiveCount) {\n      if ((object as any).isMesh) {\n        primitives.push(object as THREE.Mesh);\n      }\n    }\n  });\n\n  return primitives;\n}\n\n/**\n * Extract primitives ( `THREE.Mesh[]` ) of a node from a loaded GLTF.\n * The main purpose of this function is to distinguish primitives and children from a node that has both meshes and children.\n *\n * It utilizes the behavior that GLTFLoader adds mesh primitives to the node object ( `THREE.Group` ) first then adds its children.\n *\n * @param gltf A GLTF object taken from GLTFLoader\n * @param nodeIndex The index of the node\n */\nexport async function gltfExtractPrimitivesFromNode(gltf: GLTF, nodeIndex: number): Promise<THREE.Mesh[] | null> {\n  const node: THREE.Object3D = await gltf.parser.getDependency('node', nodeIndex);\n  return extractPrimitivesInternal(gltf, nodeIndex, node);\n}\n\n/**\n * Extract primitives ( `THREE.Mesh[]` ) of nodes from a loaded GLTF.\n * See {@link gltfExtractPrimitivesFromNode} for more details.\n *\n * It returns a map from node index to extraction result.\n * If a node does not have a mesh, the entry for the node will not be put in the returning map.\n *\n * @param gltf A GLTF object taken from GLTFLoader\n */\nexport async function gltfExtractPrimitivesFromNodes(gltf: GLTF): Promise<Map<number, THREE.Mesh[]>> {\n  const nodes: THREE.Object3D[] = await gltf.parser.getDependencies('node');\n  const map = new Map<number, THREE.Mesh[]>();\n\n  nodes.forEach((node, index) => {\n    const result = extractPrimitivesInternal(gltf, index, node);\n    if (result != null) {\n      map.set(index, result);\n    }\n  });\n\n  return map;\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMExpressionPresetName = {\n  Aa: 'aa',\n  Ih: 'ih',\n  Ou: 'ou',\n  Ee: 'ee',\n  Oh: 'oh',\n  Blink: 'blink',\n  Happy: 'happy',\n  Angry: 'angry',\n  Sad: 'sad',\n  Relaxed: 'relaxed',\n  LookUp: 'lookUp',\n  Surprised: 'surprised',\n  LookDown: 'lookDown',\n  LookLeft: 'lookLeft',\n  LookRight: 'lookRight',\n  BlinkLeft: 'blinkLeft',\n  BlinkRight: 'blinkRight',\n  Neutral: 'neutral',\n} as const;\n\nexport type VRMExpressionPresetName = (typeof VRMExpressionPresetName)[keyof typeof VRMExpressionPresetName];\n", "/**\n * Clamp the input value within [0.0 - 1.0].\n *\n * @param value The input value\n */\nexport function saturate(value: number): number {\n  return Math.max(Math.min(value, 1.0), 0.0);\n}\n", "import { VRMExpressionPresetName } from './VRMExpressionPresetName';\nimport { saturate } from '../utils/saturate';\nimport type { VRMExpression } from './VRMExpression';\n\nexport class VRMExpressionManager {\n  /**\n   * A set of name or preset name of expressions that will be overridden by {@link VRMExpression.overrideBlink}.\n   */\n  public blinkExpressionNames = ['blink', 'blinkLeft', 'blinkRight'];\n\n  /**\n   * A set of name or preset name of expressions that will be overridden by {@link VRMExpression.overrideLookAt}.\n   */\n  public lookAtExpressionNames = ['lookLeft', 'lookRight', 'lookUp', 'lookDown'];\n\n  /**\n   * A set of name or preset name of expressions that will be overridden by {@link VRMExpression.overrideMouth}.\n   */\n  public mouthExpressionNames = ['aa', 'ee', 'ih', 'oh', 'ou'];\n\n  /**\n   * A set of {@link VRMExpression}.\n   * When you want to register expressions, use {@link registerExpression}\n   */\n  private _expressions: VRMExpression[] = [];\n  public get expressions(): VRMExpression[] {\n    return this._expressions.concat();\n  }\n\n  /**\n   * A map from name to expression.\n   */\n  private _expressionMap: { [name: string]: VRMExpression } = {};\n  public get expressionMap(): { [name: string]: VRMExpression } {\n    return Object.assign({}, this._expressionMap);\n  }\n\n  /**\n   * A map from name to expression, but excluding custom expressions.\n   */\n  public get presetExpressionMap(): { [name in VRMExpressionPresetName]?: VRMExpression } {\n    const result: { [name in VRMExpressionPresetName]?: VRMExpression } = {};\n\n    const presetNameSet = new Set<string>(Object.values(VRMExpressionPresetName));\n\n    Object.entries(this._expressionMap).forEach(([name, expression]) => {\n      if (presetNameSet.has(name)) {\n        result[name as VRMExpressionPresetName] = expression;\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * A map from name to expression, but excluding preset expressions.\n   */\n  public get customExpressionMap(): { [name: string]: VRMExpression } {\n    const result: { [name: string]: VRMExpression } = {};\n\n    const presetNameSet = new Set<string>(Object.values(VRMExpressionPresetName));\n\n    Object.entries(this._expressionMap).forEach(([name, expression]) => {\n      if (!presetNameSet.has(name)) {\n        result[name] = expression;\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Create a new {@link VRMExpressionManager}.\n   */\n  public constructor() {\n    // do nothing\n  }\n\n  /**\n   * Copy the given {@link VRMExpressionManager} into this one.\n   * @param source The {@link VRMExpressionManager} you want to copy\n   * @returns this\n   */\n  public copy(source: VRMExpressionManager): this {\n    // first unregister all the expression it has\n    const expressions = this._expressions.concat();\n    expressions.forEach((expression) => {\n      this.unregisterExpression(expression);\n    });\n\n    // then register all the expression of the source\n    source._expressions.forEach((expression) => {\n      this.registerExpression(expression);\n    });\n\n    // copy remaining members\n    this.blinkExpressionNames = source.blinkExpressionNames.concat();\n    this.lookAtExpressionNames = source.lookAtExpressionNames.concat();\n    this.mouthExpressionNames = source.mouthExpressionNames.concat();\n\n    return this;\n  }\n\n  /**\n   * Returns a clone of this {@link VRMExpressionManager}.\n   * @returns Copied {@link VRMExpressionManager}\n   */\n  public clone(): VRMExpressionManager {\n    return new VRMExpressionManager().copy(this);\n  }\n\n  /**\n   * Return a registered expression.\n   * If it cannot find an expression, it will return `null` instead.\n   *\n   * @param name Name or preset name of the expression\n   */\n  public getExpression(name: VRMExpressionPresetName | string): VRMExpression | null {\n    return this._expressionMap[name] ?? null;\n  }\n\n  /**\n   * Register an expression.\n   *\n   * @param expression {@link VRMExpression} that describes the expression\n   */\n  public registerExpression(expression: VRMExpression): void {\n    this._expressions.push(expression);\n    this._expressionMap[expression.expressionName] = expression;\n  }\n\n  /**\n   * Unregister an expression.\n   *\n   * @param expression The expression you want to unregister\n   */\n  public unregisterExpression(expression: VRMExpression): void {\n    const index = this._expressions.indexOf(expression);\n    if (index === -1) {\n      console.warn('VRMExpressionManager: The specified expressions is not registered');\n    }\n\n    this._expressions.splice(index, 1);\n    delete this._expressionMap[expression.expressionName];\n  }\n\n  /**\n   * Get the current weight of the specified expression.\n   * If it doesn't have an expression of given name, it will return `null` instead.\n   *\n   * @param name Name of the expression\n   */\n  public getValue(name: VRMExpressionPresetName | string): number | null {\n    const expression = this.getExpression(name);\n    return expression?.weight ?? null;\n  }\n\n  /**\n   * Set a weight to the specified expression.\n   *\n   * @param name Name of the expression\n   * @param weight Weight\n   */\n  public setValue(name: VRMExpressionPresetName | string, weight: number): void {\n    const expression = this.getExpression(name);\n    if (expression) {\n      expression.weight = saturate(weight);\n    }\n  }\n\n  /**\n   * Reset weights of all expressions to `0.0`.\n   */\n  public resetValues(): void {\n    this._expressions.forEach((expression) => {\n      expression.weight = 0.0;\n    });\n  }\n\n  /**\n   * Get a track name of specified expression.\n   * This track name is needed to manipulate its expression via keyframe animations.\n   *\n   * @example Manipulate an expression using keyframe animation\n   * ```js\n   * const trackName = vrm.expressionManager.getExpressionTrackName( 'blink' );\n   * const track = new THREE.NumberKeyframeTrack(\n   *   name,\n   *   [ 0.0, 0.5, 1.0 ], // times\n   *   [ 0.0, 1.0, 0.0 ] // values\n   * );\n   *\n   * const clip = new THREE.AnimationClip(\n   *   'blink', // name\n   *   1.0, // duration\n   *   [ track ] // tracks\n   * );\n   *\n   * const mixer = new THREE.AnimationMixer( vrm.scene );\n   * const action = mixer.clipAction( clip );\n   * action.play();\n   * ```\n   *\n   * @param name Name of the expression\n   */\n  public getExpressionTrackName(name: VRMExpressionPresetName | string): string | null {\n    const expression = this.getExpression(name);\n    return expression ? `${expression.name}.weight` : null;\n  }\n\n  /**\n   * Update every expressions.\n   */\n  public update(): void {\n    // see how much we should override certain expressions\n    const weightMultipliers = this._calculateWeightMultipliers();\n\n    // reset expression binds first\n    this._expressions.forEach((expression) => {\n      expression.clearAppliedWeight();\n    });\n\n    // then apply binds\n    this._expressions.forEach((expression) => {\n      let multiplier = 1.0;\n      const name = expression.expressionName;\n\n      if (this.blinkExpressionNames.indexOf(name) !== -1) {\n        multiplier *= weightMultipliers.blink;\n      }\n\n      if (this.lookAtExpressionNames.indexOf(name) !== -1) {\n        multiplier *= weightMultipliers.lookAt;\n      }\n\n      if (this.mouthExpressionNames.indexOf(name) !== -1) {\n        multiplier *= weightMultipliers.mouth;\n      }\n\n      expression.applyWeight({ multiplier });\n    });\n  }\n\n  /**\n   * Calculate sum of override amounts to see how much we should multiply weights of certain expressions.\n   */\n  private _calculateWeightMultipliers(): {\n    blink: number;\n    lookAt: number;\n    mouth: number;\n  } {\n    let blink = 1.0;\n    let lookAt = 1.0;\n    let mouth = 1.0;\n\n    this._expressions.forEach((expression) => {\n      blink -= expression.overrideBlinkAmount;\n      lookAt -= expression.overrideLookAtAmount;\n      mouth -= expression.overrideMouthAmount;\n    });\n\n    blink = Math.max(0.0, blink);\n    lookAt = Math.max(0.0, lookAt);\n    mouth = Math.max(0.0, mouth);\n\n    return { blink, lookAt, mouth };\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMExpressionMaterialColorType = {\n  Color: 'color',\n  EmissionColor: 'emissionColor',\n  ShadeColor: 'shadeColor',\n  MatcapColor: 'matcapColor',\n  RimColor: 'rimColor',\n  OutlineColor: 'outlineColor',\n} as const;\n\nexport type VRMExpressionMaterialColorType =\n  (typeof VRMExpressionMaterialColorType)[keyof typeof VRMExpressionMaterialColorType];\n\nexport const v0ExpressionMaterialColorMap: { [key: string]: VRMExpressionMaterialColorType | undefined } = {\n  _Color: VRMExpressionMaterialColorType.Color,\n  _EmissionColor: VRMExpressionMaterialColorType.EmissionColor,\n  _ShadeColor: VRMExpressionMaterialColorType.ShadeColor,\n  _RimColor: VRMExpressionMaterialColorType.RimColor,\n  _OutlineColor: VRMExpressionMaterialColorType.OutlineColor,\n};\n", "import * as THREE from 'three';\nimport type { VRMExpressionBind } from './VRMExpressionBind';\nimport type { VRMExpressionMaterialColorType } from './VRMExpressionMaterialColorType';\n\nconst _color = new THREE.Color();\n\ninterface ColorBindState {\n  propertyName: string;\n  initialValue: THREE.Color;\n  deltaValue: THREE.Color;\n}\n\ninterface AlphaBindState {\n  propertyName: string;\n  initialValue: number;\n  deltaValue: number;\n}\n\ninterface BindState {\n  color: ColorBindState | null;\n  alpha: AlphaBindState | null;\n}\n\n/**\n * A bind of expression influences to a material color.\n */\nexport class VRMExpressionMaterialColorBind implements VRMExpressionBind {\n  /**\n   * Mapping of property names from VRMC/materialColorBinds.type to three.js/Material.\n   * The first element stands for color channels, the second element stands for the alpha channel.\n   * The second element can be null if the target property doesn't exist.\n   */\n  // TODO: We might want to use the `satisfies` operator once we bump TS to 4.9 or higher\n  // See: https://github.com/pixiv/three-vrm/pull/1323#discussion_r1374020035\n  private static _propertyNameMapMap: {\n    [distinguisher: string]: { [type in VRMExpressionMaterialColorType]?: readonly [string, string | null] };\n  } = {\n    isMeshStandardMaterial: {\n      color: ['color', 'opacity'],\n      emissionColor: ['emissive', null],\n    },\n    isMeshBasicMaterial: {\n      color: ['color', 'opacity'],\n    },\n    isMToonMaterial: {\n      color: ['color', 'opacity'],\n      emissionColor: ['emissive', null],\n      outlineColor: ['outlineColorFactor', null],\n      matcapColor: ['matcapFactor', null],\n      rimColor: ['parametricRimColorFactor', null],\n      shadeColor: ['shadeColorFactor', null],\n    },\n  };\n\n  /**\n   * The target material.\n   */\n  public readonly material: THREE.Material;\n\n  /**\n   * The type of the target property of the material.\n   */\n  public readonly type: VRMExpressionMaterialColorType;\n\n  /**\n   * The target color.\n   */\n  public readonly targetValue: THREE.Color;\n\n  /**\n   * The target alpha.\n   */\n  public readonly targetAlpha: number;\n\n  /**\n   * Its binding state.\n   * If it cannot find the target property in the constructor, each property will be null instead.\n   */\n  private _state: BindState;\n\n  public constructor({\n    material,\n    type,\n    targetValue,\n    targetAlpha,\n  }: {\n    /**\n     * The target material.\n     */\n    material: THREE.Material;\n\n    /**\n     * The type of the target property of the material.\n     */\n    type: VRMExpressionMaterialColorType;\n\n    /**\n     * The target color.\n     */\n    targetValue: THREE.Color;\n\n    /**\n     * The target alpha.\n     */\n    targetAlpha?: number;\n  }) {\n    this.material = material;\n    this.type = type;\n    this.targetValue = targetValue;\n    this.targetAlpha = targetAlpha ?? 1.0;\n\n    // init bind state\n    const color = this._initColorBindState();\n    const alpha = this._initAlphaBindState();\n    this._state = { color, alpha };\n  }\n\n  public applyWeight(weight: number): void {\n    const { color, alpha } = this._state;\n\n    if (color != null) {\n      const { propertyName, deltaValue } = color;\n\n      const target = (this.material as any)[propertyName] as THREE.Color;\n      if (target != undefined) {\n        target.add(_color.copy(deltaValue).multiplyScalar(weight));\n      }\n    }\n\n    if (alpha != null) {\n      const { propertyName, deltaValue } = alpha;\n\n      const target = (this.material as any)[propertyName] as number;\n      if (target != undefined) {\n        ((this.material as any)[propertyName] as number) += deltaValue * weight;\n      }\n    }\n  }\n\n  public clearAppliedWeight(): void {\n    const { color, alpha } = this._state;\n\n    if (color != null) {\n      const { propertyName, initialValue } = color;\n\n      const target = (this.material as any)[propertyName] as THREE.Color;\n      if (target != undefined) {\n        target.copy(initialValue);\n      }\n    }\n\n    if (alpha != null) {\n      const { propertyName, initialValue } = alpha;\n\n      const target = (this.material as any)[propertyName] as number;\n      if (target != undefined) {\n        ((this.material as any)[propertyName] as number) = initialValue;\n      }\n    }\n  }\n\n  private _initColorBindState(): ColorBindState | null {\n    const { material, type, targetValue } = this;\n\n    const propertyNameMap = this._getPropertyNameMap();\n    const propertyName = propertyNameMap?.[type]?.[0] ?? null;\n\n    if (propertyName == null) {\n      console.warn(\n        `Tried to add a material color bind to the material ${\n          material.name ?? '(no name)'\n        }, the type ${type} but the material or the type is not supported.`,\n      );\n\n      return null;\n    }\n\n    const target = (material as any)[propertyName] as THREE.Color;\n\n    const initialValue = target.clone();\n\n    // \u8CA0\u306E\u5024\u3092\u4FDD\u6301\u3059\u308B\u305F\u3081\u306BColor.sub\u3092\u4F7F\u308F\u305A\u306B\u5DEE\u5206\u3092\u8A08\u7B97\u3059\u308B\n    const deltaValue = new THREE.Color(\n      targetValue.r - initialValue.r,\n      targetValue.g - initialValue.g,\n      targetValue.b - initialValue.b,\n    );\n\n    return { propertyName, initialValue, deltaValue };\n  }\n\n  private _initAlphaBindState(): AlphaBindState | null {\n    const { material, type, targetAlpha } = this;\n\n    const propertyNameMap = this._getPropertyNameMap();\n    const propertyName = propertyNameMap?.[type]?.[1] ?? null;\n\n    if (propertyName == null && targetAlpha !== 1.0) {\n      console.warn(\n        `Tried to add a material alpha bind to the material ${\n          material.name ?? '(no name)'\n        }, the type ${type} but the material or the type does not support alpha.`,\n      );\n\n      return null;\n    }\n\n    if (propertyName == null) {\n      return null;\n    }\n\n    const initialValue = (material as any)[propertyName] as number;\n\n    const deltaValue = targetAlpha - initialValue;\n\n    return { propertyName, initialValue, deltaValue };\n  }\n\n  private _getPropertyNameMap():\n    | { [type in VRMExpressionMaterialColorType]?: readonly [string, string | null] }\n    | null {\n    return (\n      Object.entries(VRMExpressionMaterialColorBind._propertyNameMapMap).find(([distinguisher]) => {\n        return (this.material as any)[distinguisher] === true;\n      })?.[1] ?? null\n    );\n  }\n}\n", "import type * as THREE from 'three';\nimport type { VRMExpressionBind } from './VRMExpressionBind';\n\n/**\n * A bind of {@link VRMExpression} influences to morph targets.\n */\nexport class VRMExpressionMorphTargetBind implements VRMExpressionBind {\n  /**\n   * The mesh primitives that attached to target mesh.\n   */\n  public readonly primitives: THREE.Mesh[];\n\n  /**\n   * The index of the morph target in the mesh.\n   */\n  public readonly index: number;\n\n  /**\n   * The weight value of target morph target. Ranging in [0.0 - 1.0].\n   */\n  public readonly weight: number;\n\n  public constructor({\n    primitives,\n    index,\n    weight,\n  }: {\n    /**\n     * The mesh primitives that attached to target mesh.\n     */\n    primitives: THREE.Mesh[];\n\n    /**\n     * The index of the morph target in the mesh.\n     */\n    index: number;\n\n    /**\n     * The weight value of target morph target. Ranging in [0.0 - 1.0].\n     */\n    weight: number;\n  }) {\n    this.primitives = primitives;\n    this.index = index;\n    this.weight = weight;\n  }\n\n  public applyWeight(weight: number): void {\n    this.primitives.forEach((mesh) => {\n      if (mesh.morphTargetInfluences?.[this.index] != null) {\n        mesh.morphTargetInfluences[this.index] += this.weight * weight;\n      }\n    });\n  }\n\n  public clearAppliedWeight(): void {\n    this.primitives.forEach((mesh) => {\n      if (mesh.morphTargetInfluences?.[this.index] != null) {\n        mesh.morphTargetInfluences[this.index] = 0.0;\n      }\n    });\n  }\n}\n", "import * as THREE from 'three';\nimport type { VRMExpressionBind } from './VRMExpressionBind';\n\nconst _v2 = new THREE.Vector2();\n\n/**\n * A bind of expression influences to texture transforms.\n */\nexport class VRMExpressionTextureTransformBind implements VRMExpressionBind {\n  private static _propertyNamesMap: { [distinguisher: string]: string[] } = {\n    isMeshStandardMaterial: [\n      'map',\n      'emissiveMap',\n      'bumpMap',\n      'normalMap',\n      'displacementMap',\n      'roughnessMap',\n      'metalnessMap',\n      'alphaMap',\n    ],\n    isMeshBasicMaterial: ['map', 'specularMap', 'alphaMap'],\n    isMToonMaterial: [\n      'map',\n      'normalMap',\n      'emissiveMap',\n      'shadeMultiplyTexture',\n      'rimMultiplyTexture',\n      'outlineWidthMultiplyTexture',\n      'uvAnimationMaskTexture',\n    ],\n  };\n\n  /**\n   * The target material.\n   */\n  public readonly material: THREE.Material;\n\n  /**\n   * The uv scale of the texture.\n   */\n  public readonly scale: THREE.Vector2;\n\n  /**\n   * The uv offset of the texture.\n   */\n  public readonly offset: THREE.Vector2;\n\n  /**\n   * The list of texture names and its state that should be transformed by this bind.\n   */\n  private _properties: {\n    name: string;\n    initialOffset: THREE.Vector2;\n    initialScale: THREE.Vector2;\n    deltaOffset: THREE.Vector2;\n    deltaScale: THREE.Vector2;\n  }[];\n\n  public constructor({\n    material,\n    scale,\n    offset,\n  }: {\n    /**\n     * The target material.\n     */\n    material: THREE.Material;\n\n    /**\n     * The uv scale of the texture.\n     */\n    scale: THREE.Vector2;\n\n    /**\n     * The uv offset of the texture.\n     */\n    offset: THREE.Vector2;\n  }) {\n    this.material = material;\n    this.scale = scale;\n    this.offset = offset;\n\n    const propertyNames = Object.entries(VRMExpressionTextureTransformBind._propertyNamesMap).find(\n      ([distinguisher]) => {\n        return (material as any)[distinguisher] === true;\n      },\n    )?.[1];\n\n    if (propertyNames == null) {\n      console.warn(\n        `Tried to add a texture transform bind to the material ${\n          material.name ?? '(no name)'\n        } but the material is not supported.`,\n      );\n\n      this._properties = [];\n    } else {\n      this._properties = [];\n\n      propertyNames.forEach((propertyName) => {\n        const texture = ((material as any)[propertyName] as THREE.Texture | undefined)?.clone();\n        if (!texture) {\n          return null;\n        }\n\n        (material as any)[propertyName] = texture; // because the texture is cloned\n\n        const initialOffset = texture.offset.clone();\n        const initialScale = texture.repeat.clone();\n        const deltaOffset = offset.clone().sub(initialOffset);\n        const deltaScale = scale.clone().sub(initialScale);\n\n        this._properties.push({\n          name: propertyName,\n          initialOffset,\n          deltaOffset,\n          initialScale,\n          deltaScale,\n        });\n      });\n    }\n  }\n\n  public applyWeight(weight: number): void {\n    this._properties.forEach((property) => {\n      const target = (this.material as any)[property.name] as THREE.Texture;\n      if (target === undefined) {\n        return;\n      } // TODO: we should kick this at `addMaterialValue`\n\n      target.offset.add(_v2.copy(property.deltaOffset).multiplyScalar(weight));\n      target.repeat.add(_v2.copy(property.deltaScale).multiplyScalar(weight));\n    });\n  }\n\n  public clearAppliedWeight(): void {\n    this._properties.forEach((property) => {\n      const target = (this.material as any)[property.name] as THREE.Texture;\n      if (target === undefined) {\n        return;\n      } // TODO: we should kick this at `addMaterialValue`\n\n      target.offset.copy(property.initialOffset);\n      target.repeat.copy(property.initialScale);\n    });\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMExpressionOverrideType = {\n  None: 'none',\n  Block: 'block',\n  Blend: 'blend',\n} as const;\n\nexport type VRMExpressionOverrideType = (typeof VRMExpressionOverrideType)[keyof typeof VRMExpressionOverrideType];\n", "import type { VRMFirstPersonMeshAnnotation } from './VRMFirstPersonMeshAnnotation';\nimport * as THREE from 'three';\nimport type { VRMHumanoid } from '../humanoid';\n\nexport class VRMFirstPerson {\n  /**\n   * A default camera layer for `FirstPersonOnly` layer.\n   *\n   * @see {@link firstPersonOnlyLayer}\n   */\n  public static readonly DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;\n\n  /**\n   * A default camera layer for `ThirdPersonOnly` layer.\n   *\n   * @see {@link thirdPersonOnlyLayer}\n   */\n  public static readonly DEFAULT_THIRDPERSON_ONLY_LAYER = 10;\n\n  /**\n   * Its associated {@link VRMHumanoid}.\n   */\n  public readonly humanoid: VRMHumanoid;\n  public meshAnnotations: VRMFirstPersonMeshAnnotation[];\n\n  private _firstPersonOnlyLayer = VRMFirstPerson.DEFAULT_FIRSTPERSON_ONLY_LAYER;\n  private _thirdPersonOnlyLayer = VRMFirstPerson.DEFAULT_THIRDPERSON_ONLY_LAYER;\n\n  private _initializedLayers = false;\n\n  /**\n   * Create a new VRMFirstPerson object.\n   *\n   * @param humanoid A {@link VRMHumanoid}\n   * @param meshAnnotations A {@link VRMFirstPersonMeshAnnotation}\n   */\n  public constructor(humanoid: VRMHumanoid, meshAnnotations: VRMFirstPersonMeshAnnotation[]) {\n    this.humanoid = humanoid;\n    this.meshAnnotations = meshAnnotations;\n  }\n\n  /**\n   * Copy the given {@link VRMFirstPerson} into this one.\n   * {@link humanoid} must be same as the source one.\n   * @param source The {@link VRMFirstPerson} you want to copy\n   * @returns this\n   */\n  public copy(source: VRMFirstPerson): this {\n    if (this.humanoid !== source.humanoid) {\n      throw new Error('VRMFirstPerson: humanoid must be same in order to copy');\n    }\n\n    this.meshAnnotations = source.meshAnnotations.map((annotation) => ({\n      meshes: annotation.meshes.concat(),\n      type: annotation.type,\n    }));\n\n    return this;\n  }\n\n  /**\n   * Returns a clone of this {@link VRMFirstPerson}.\n   * @returns Copied {@link VRMFirstPerson}\n   */\n  public clone(): VRMFirstPerson {\n    return new VRMFirstPerson(this.humanoid, this.meshAnnotations).copy(this);\n  }\n\n  /**\n   * A camera layer represents `FirstPersonOnly` layer.\n   * Note that **you must call {@link setup} first before you use the layer feature** or it does not work properly.\n   *\n   * The value is {@link DEFAULT_FIRSTPERSON_ONLY_LAYER} by default but you can change the layer by specifying via {@link setup} if you prefer.\n   *\n   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/\n   * @see https://threejs.org/docs/#api/en/core/Layers\n   */\n  public get firstPersonOnlyLayer(): number {\n    return this._firstPersonOnlyLayer;\n  }\n\n  /**\n   * A camera layer represents `ThirdPersonOnly` layer.\n   * Note that **you must call {@link setup} first before you use the layer feature** or it does not work properly.\n   *\n   * The value is {@link DEFAULT_THIRDPERSON_ONLY_LAYER} by default but you can change the layer by specifying via {@link setup} if you prefer.\n   *\n   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/\n   * @see https://threejs.org/docs/#api/en/core/Layers\n   */\n  public get thirdPersonOnlyLayer(): number {\n    return this._thirdPersonOnlyLayer;\n  }\n\n  /**\n   * In this method, it assigns layers for every meshes based on mesh annotations.\n   * You must call this method first before you use the layer feature.\n   *\n   * This is an equivalent of [VRMFirstPerson.Setup](https://github.com/vrm-c/UniVRM/blob/73a5bd8fcddaa2a7a8735099a97e63c9db3e5ea0/Assets/VRM/Runtime/FirstPerson/VRMFirstPerson.cs#L295-L299) of the UniVRM.\n   *\n   * The `cameraLayer` parameter specifies which layer will be assigned for `FirstPersonOnly` / `ThirdPersonOnly`.\n   * In UniVRM, we specified those by naming each desired layer as `FIRSTPERSON_ONLY_LAYER` / `THIRDPERSON_ONLY_LAYER`\n   * but we are going to specify these layers at here since we are unable to name layers in Three.js.\n   *\n   * @param cameraLayer Specify which layer will be for `FirstPersonOnly` / `ThirdPersonOnly`.\n   */\n  public setup({\n    firstPersonOnlyLayer = VRMFirstPerson.DEFAULT_FIRSTPERSON_ONLY_LAYER,\n    thirdPersonOnlyLayer = VRMFirstPerson.DEFAULT_THIRDPERSON_ONLY_LAYER,\n  } = {}): void {\n    if (this._initializedLayers) {\n      return;\n    }\n    this._firstPersonOnlyLayer = firstPersonOnlyLayer;\n    this._thirdPersonOnlyLayer = thirdPersonOnlyLayer;\n\n    this.meshAnnotations.forEach((item) => {\n      item.meshes.forEach((mesh) => {\n        if (item.type === 'firstPersonOnly') {\n          mesh.layers.set(this._firstPersonOnlyLayer);\n          mesh.traverse((child) => child.layers.set(this._firstPersonOnlyLayer));\n        } else if (item.type === 'thirdPersonOnly') {\n          mesh.layers.set(this._thirdPersonOnlyLayer);\n          mesh.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n        } else if (item.type === 'auto') {\n          this._createHeadlessModel(mesh);\n        }\n      });\n    });\n\n    this._initializedLayers = true;\n  }\n\n  private _excludeTriangles(triangles: number[], bws: number[][], skinIndex: number[][], exclude: number[]): number {\n    let count = 0;\n    if (bws != null && bws.length > 0) {\n      for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i];\n        const b = triangles[i + 1];\n        const c = triangles[i + 2];\n        const bw0 = bws[a];\n        const skin0 = skinIndex[a];\n\n        if (bw0[0] > 0 && exclude.includes(skin0[0])) continue;\n        if (bw0[1] > 0 && exclude.includes(skin0[1])) continue;\n        if (bw0[2] > 0 && exclude.includes(skin0[2])) continue;\n        if (bw0[3] > 0 && exclude.includes(skin0[3])) continue;\n\n        const bw1 = bws[b];\n        const skin1 = skinIndex[b];\n        if (bw1[0] > 0 && exclude.includes(skin1[0])) continue;\n        if (bw1[1] > 0 && exclude.includes(skin1[1])) continue;\n        if (bw1[2] > 0 && exclude.includes(skin1[2])) continue;\n        if (bw1[3] > 0 && exclude.includes(skin1[3])) continue;\n\n        const bw2 = bws[c];\n        const skin2 = skinIndex[c];\n        if (bw2[0] > 0 && exclude.includes(skin2[0])) continue;\n        if (bw2[1] > 0 && exclude.includes(skin2[1])) continue;\n        if (bw2[2] > 0 && exclude.includes(skin2[2])) continue;\n        if (bw2[3] > 0 && exclude.includes(skin2[3])) continue;\n\n        triangles[count++] = a;\n        triangles[count++] = b;\n        triangles[count++] = c;\n      }\n    }\n    return count;\n  }\n\n  private _createErasedMesh(src: THREE.SkinnedMesh, erasingBonesIndex: number[]): THREE.SkinnedMesh {\n    const dst = new THREE.SkinnedMesh(src.geometry.clone(), src.material);\n    dst.name = `${src.name}(erase)`;\n    dst.frustumCulled = src.frustumCulled;\n    dst.layers.set(this._firstPersonOnlyLayer);\n\n    const geometry = dst.geometry;\n\n    const skinIndexAttr = geometry.getAttribute('skinIndex');\n    const skinIndexAttrArray = skinIndexAttr instanceof THREE.GLBufferAttribute ? [] : skinIndexAttr.array;\n    const skinIndex = [];\n    for (let i = 0; i < skinIndexAttrArray.length; i += 4) {\n      skinIndex.push([\n        skinIndexAttrArray[i],\n        skinIndexAttrArray[i + 1],\n        skinIndexAttrArray[i + 2],\n        skinIndexAttrArray[i + 3],\n      ]);\n    }\n\n    const skinWeightAttr = geometry.getAttribute('skinWeight');\n    const skinWeightAttrArray = skinWeightAttr instanceof THREE.GLBufferAttribute ? [] : skinWeightAttr.array;\n    const skinWeight = [];\n    for (let i = 0; i < skinWeightAttrArray.length; i += 4) {\n      skinWeight.push([\n        skinWeightAttrArray[i],\n        skinWeightAttrArray[i + 1],\n        skinWeightAttrArray[i + 2],\n        skinWeightAttrArray[i + 3],\n      ]);\n    }\n\n    const index = geometry.getIndex();\n    if (!index) {\n      throw new Error(\"The geometry doesn't have an index buffer\");\n    }\n    const oldTriangles = Array.from(index.array);\n\n    const count = this._excludeTriangles(oldTriangles, skinWeight, skinIndex, erasingBonesIndex);\n    const newTriangle: number[] = [];\n    for (let i = 0; i < count; i++) {\n      newTriangle[i] = oldTriangles[i];\n    }\n    geometry.setIndex(newTriangle);\n\n    // mtoon material includes onBeforeRender. this is unsupported at SkinnedMesh#clone\n    if (src.onBeforeRender) {\n      dst.onBeforeRender = src.onBeforeRender;\n    }\n    dst.bind(new THREE.Skeleton(src.skeleton.bones, src.skeleton.boneInverses), new THREE.Matrix4());\n    return dst;\n  }\n\n  private _createHeadlessModelForSkinnedMesh(parent: THREE.Object3D, mesh: THREE.SkinnedMesh): void {\n    const eraseBoneIndexes: number[] = [];\n    mesh.skeleton.bones.forEach((bone, index) => {\n      if (this._isEraseTarget(bone)) eraseBoneIndexes.push(index);\n    });\n\n    // Unlike UniVRM we don't copy mesh if no invisible bone was found\n    if (!eraseBoneIndexes.length) {\n      mesh.layers.enable(this._thirdPersonOnlyLayer);\n      mesh.layers.enable(this._firstPersonOnlyLayer);\n      return;\n    }\n    mesh.layers.set(this._thirdPersonOnlyLayer);\n    const newMesh = this._createErasedMesh(mesh, eraseBoneIndexes);\n    parent.add(newMesh);\n  }\n\n  private _createHeadlessModel(node: THREE.Object3D): void {\n    if (node.type === 'Group') {\n      node.layers.set(this._thirdPersonOnlyLayer);\n      if (this._isEraseTarget(node)) {\n        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      } else {\n        const parent = new THREE.Group();\n        parent.name = `_headless_${node.name}`;\n        parent.layers.set(this._firstPersonOnlyLayer);\n        node.parent!.add(parent);\n        node.children\n          .filter((child) => child.type === 'SkinnedMesh')\n          .forEach((child) => {\n            const skinnedMesh = child as THREE.SkinnedMesh;\n            this._createHeadlessModelForSkinnedMesh(parent, skinnedMesh);\n          });\n      }\n    } else if (node.type === 'SkinnedMesh') {\n      const skinnedMesh = node as THREE.SkinnedMesh;\n      this._createHeadlessModelForSkinnedMesh(node.parent!, skinnedMesh);\n    } else {\n      if (this._isEraseTarget(node)) {\n        node.layers.set(this._thirdPersonOnlyLayer);\n        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      }\n    }\n  }\n\n  private _isEraseTarget(bone: THREE.Object3D): boolean {\n    if (bone === this.humanoid.getRawBoneNode('head')) {\n      return true;\n    } else if (!bone.parent) {\n      return false;\n    } else {\n      return this._isEraseTarget(bone.parent);\n    }\n  }\n}\n", "import type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport type { VRMHumanoid } from '../humanoid/VRMHumanoid';\nimport { gltfExtractPrimitivesFromNodes } from '../utils/gltfExtractPrimitivesFromNode';\nimport { VRMFirstPerson } from './VRMFirstPerson';\nimport type { VRMFirstPersonMeshAnnotation } from './VRMFirstPersonMeshAnnotation';\nimport type { VRMFirstPersonMeshAnnotationType } from './VRMFirstPersonMeshAnnotationType';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRMFirstPerson} from a VRM extension of a GLTF.\n */\nexport class VRMFirstPersonLoaderPlugin implements GLTFLoaderPlugin {\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMFirstPersonLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser) {\n    this.parser = parser;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    const vrmHumanoid = gltf.userData.vrmHumanoid as VRMHumanoid | undefined;\n\n    // explicitly distinguish null and undefined\n    // since vrmHumanoid might be null as a result\n    if (vrmHumanoid === null) {\n      return;\n    } else if (vrmHumanoid === undefined) {\n      throw new Error(\n        'VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first',\n      );\n    }\n\n    gltf.userData.vrmFirstPerson = await this._import(gltf, vrmHumanoid);\n  }\n\n  /**\n   * Import a {@link VRMFirstPerson} from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   * @param humanoid A {@link VRMHumanoid} instance that represents the VRM\n   */\n\n  private async _import(gltf: GLTF, humanoid: VRMHumanoid | null): Promise<VRMFirstPerson | null> {\n    if (humanoid == null) {\n      return null;\n    }\n\n    const v1Result = await this._v1Import(gltf, humanoid);\n    if (v1Result) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf, humanoid);\n    if (v0Result) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(gltf: GLTF, humanoid: VRMHumanoid): Promise<VRMFirstPerson | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (!extension) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaFirstPerson = extension.firstPerson;\n\n    const meshAnnotations: VRMFirstPersonMeshAnnotation[] = [];\n    const nodePrimitivesMap = await gltfExtractPrimitivesFromNodes(gltf);\n    Array.from(nodePrimitivesMap.entries()).forEach(([nodeIndex, primitives]) => {\n      const annotation = schemaFirstPerson?.meshAnnotations?.find((a) => a.node === nodeIndex);\n\n      meshAnnotations.push({\n        meshes: primitives,\n        type: annotation?.type ?? 'auto',\n      });\n    });\n\n    return new VRMFirstPerson(humanoid, meshAnnotations);\n  }\n\n  private async _v0Import(gltf: GLTF, humanoid: VRMHumanoid): Promise<VRMFirstPerson | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson: V0VRM.FirstPerson | undefined = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const meshAnnotations: VRMFirstPersonMeshAnnotation[] = [];\n    const nodePrimitivesMap = await gltfExtractPrimitivesFromNodes(gltf);\n\n    Array.from(nodePrimitivesMap.entries()).forEach(([nodeIndex, primitives]) => {\n      const schemaNode = json.nodes![nodeIndex];\n\n      const flag = schemaFirstPerson.meshAnnotations\n        ? schemaFirstPerson.meshAnnotations.find((a) => a.mesh === schemaNode.mesh)\n        : undefined;\n\n      meshAnnotations.push({\n        meshes: primitives,\n        type: this._convertV0FlagToV1Type(flag?.firstPersonFlag),\n      });\n    });\n\n    return new VRMFirstPerson(humanoid, meshAnnotations);\n  }\n\n  private _convertV0FlagToV1Type(flag: string | undefined): VRMFirstPersonMeshAnnotationType {\n    if (flag === 'FirstPersonOnly') {\n      return 'firstPersonOnly';\n    } else if (flag === 'ThirdPersonOnly') {\n      return 'thirdPersonOnly';\n    } else if (flag === 'Both') {\n      return 'both';\n    } else {\n      // The default value is 'Auto' even in VRM0\n      // See: https://github.com/vrm-c/UniVRM/blob/07d98e2f1abc528d387f860d2224d0855b0d0b59/Assets/VRM/Runtime/FirstPerson/VRMFirstPerson.cs#L117-L119\n      return 'auto';\n    }\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMFirstPersonMeshAnnotationType = {\n  Auto: 'auto',\n  Both: 'both',\n  ThirdPersonOnly: 'thirdPersonOnly',\n  FirstPersonOnly: 'firstPersonOnly',\n} as const;\n\nexport type VRMFirstPersonMeshAnnotationType =\n  (typeof VRMFirstPersonMeshAnnotationType)[keyof typeof VRMFirstPersonMeshAnnotationType];\n", "import * as THREE from 'three';\nimport { VRMHumanBone } from '../VRMHumanBone';\nimport { VRMHumanoid } from '../VRMHumanoid';\n\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\n\nexport class VRMHumanoidHelper extends THREE.Group {\n  public readonly vrmHumanoid: VRMHumanoid;\n  private _boneAxesMap: Map<VRMHumanBone, THREE.AxesHelper>;\n\n  public constructor(humanoid: VRMHumanoid) {\n    super();\n\n    this.vrmHumanoid = humanoid;\n\n    this._boneAxesMap = new Map();\n\n    Object.values(humanoid.humanBones).forEach((bone) => {\n      const helper = new THREE.AxesHelper(1.0);\n\n      helper.matrixAutoUpdate = false;\n\n      (helper.material as THREE.Material).depthTest = false;\n      (helper.material as THREE.Material).depthWrite = false;\n\n      this.add(helper);\n\n      this._boneAxesMap.set(bone, helper);\n    });\n  }\n\n  public dispose(): void {\n    Array.from(this._boneAxesMap.values()).forEach((axes) => {\n      axes.geometry.dispose();\n      (axes.material as THREE.Material).dispose();\n    });\n  }\n\n  public updateMatrixWorld(force: boolean): void {\n    Array.from(this._boneAxesMap.entries()).forEach(([bone, axes]) => {\n      bone.node.updateWorldMatrix(true, false);\n\n      bone.node.matrixWorld.decompose(_v3A, _quatA, _v3B);\n\n      const scale = _v3A.set(0.1, 0.1, 0.1).divide(_v3B);\n      axes.matrix.copy(bone.node.matrixWorld).scale(scale);\n    });\n\n    super.updateMatrixWorld(force);\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { VRMHumanBoneName } from './VRMHumanBoneName';\n\n/**\n * The list of {@link VRMHumanBoneName}. Dependency aware.\n */\nexport const VRMHumanBoneList: VRMHumanBoneName[] = [\n  'hips',\n  'spine',\n  'chest',\n  'upperChest',\n  'neck',\n\n  'head',\n  'leftEye',\n  'rightEye',\n  'jaw',\n\n  'leftUpperLeg',\n  'leftLowerLeg',\n  'leftFoot',\n  'leftToes',\n\n  'rightUpperLeg',\n  'rightLowerLeg',\n  'rightFoot',\n  'rightToes',\n\n  'leftShoulder',\n  'leftUpperArm',\n  'leftLowerArm',\n  'leftHand',\n\n  'rightShoulder',\n  'rightUpperArm',\n  'rightLowerArm',\n  'rightHand',\n\n  'leftThumbMetacarpal',\n  'leftThumbProximal',\n  'leftThumbDistal',\n  'leftIndexProximal',\n  'leftIndexIntermediate',\n  'leftIndexDistal',\n  'leftMiddleProximal',\n  'leftMiddleIntermediate',\n  'leftMiddleDistal',\n  'leftRingProximal',\n  'leftRingIntermediate',\n  'leftRingDistal',\n  'leftLittleProximal',\n  'leftLittleIntermediate',\n  'leftLittleDistal',\n\n  'rightThumbMetacarpal',\n  'rightThumbProximal',\n  'rightThumbDistal',\n  'rightIndexProximal',\n  'rightIndexIntermediate',\n  'rightIndexDistal',\n  'rightMiddleProximal',\n  'rightMiddleIntermediate',\n  'rightMiddleDistal',\n  'rightRingProximal',\n  'rightRingIntermediate',\n  'rightRingDistal',\n  'rightLittleProximal',\n  'rightLittleIntermediate',\n  'rightLittleDistal',\n];\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * The names of {@link VRMHumanoid} bone names.\n *\n * Ref: https://github.com/vrm-c/vrm-specification/blob/master/specification/VRMC_vrm-1.0/humanoid.md\n */\nexport const VRMHumanBoneName = {\n  Hips: 'hips',\n  Spine: 'spine',\n  Chest: 'chest',\n  UpperChest: 'upperChest',\n  Neck: 'neck',\n\n  Head: 'head',\n  LeftEye: 'leftEye',\n  RightEye: 'rightEye',\n  Jaw: 'jaw',\n\n  LeftUpperLeg: 'leftUpperLeg',\n  LeftLowerLeg: 'leftLowerLeg',\n  LeftFoot: 'leftFoot',\n  LeftToes: 'leftToes',\n\n  RightUpperLeg: 'rightUpperLeg',\n  RightLowerLeg: 'rightLowerLeg',\n  RightFoot: 'rightFoot',\n  RightToes: 'rightToes',\n\n  LeftShoulder: 'leftShoulder',\n  LeftUpperArm: 'leftUpperArm',\n  LeftLowerArm: 'leftLowerArm',\n  LeftHand: 'leftHand',\n\n  RightShoulder: 'rightShoulder',\n  RightUpperArm: 'rightUpperArm',\n  RightLowerArm: 'rightLowerArm',\n  RightHand: 'rightHand',\n\n  LeftThumbMetacarpal: 'leftThumbMetacarpal',\n  LeftThumbProximal: 'leftThumbProximal',\n  LeftThumbDistal: 'leftThumbDistal',\n  LeftIndexProximal: 'leftIndexProximal',\n  LeftIndexIntermediate: 'leftIndexIntermediate',\n  LeftIndexDistal: 'leftIndexDistal',\n  LeftMiddleProximal: 'leftMiddleProximal',\n  LeftMiddleIntermediate: 'leftMiddleIntermediate',\n  LeftMiddleDistal: 'leftMiddleDistal',\n  LeftRingProximal: 'leftRingProximal',\n  LeftRingIntermediate: 'leftRingIntermediate',\n  LeftRingDistal: 'leftRingDistal',\n  LeftLittleProximal: 'leftLittleProximal',\n  LeftLittleIntermediate: 'leftLittleIntermediate',\n  LeftLittleDistal: 'leftLittleDistal',\n\n  RightThumbMetacarpal: 'rightThumbMetacarpal',\n  RightThumbProximal: 'rightThumbProximal',\n  RightThumbDistal: 'rightThumbDistal',\n  RightIndexProximal: 'rightIndexProximal',\n  RightIndexIntermediate: 'rightIndexIntermediate',\n  RightIndexDistal: 'rightIndexDistal',\n  RightMiddleProximal: 'rightMiddleProximal',\n  RightMiddleIntermediate: 'rightMiddleIntermediate',\n  RightMiddleDistal: 'rightMiddleDistal',\n  RightRingProximal: 'rightRingProximal',\n  RightRingIntermediate: 'rightRingIntermediate',\n  RightRingDistal: 'rightRingDistal',\n  RightLittleProximal: 'rightLittleProximal',\n  RightLittleIntermediate: 'rightLittleIntermediate',\n  RightLittleDistal: 'rightLittleDistal',\n} as const;\n\nexport type VRMHumanBoneName = (typeof VRMHumanBoneName)[keyof typeof VRMHumanBoneName];\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { VRMHumanBoneName } from './VRMHumanBoneName';\n\n/**\n * An object that maps from {@link VRMHumanBoneName} to its parent {@link VRMHumanBoneName}.\n *\n * Ref: https://github.com/vrm-c/vrm-specification/blob/master/specification/VRMC_vrm-1.0/humanoid.md\n */\nexport const VRMHumanBoneParentMap: { [bone in VRMHumanBoneName]: VRMHumanBoneName | null } = {\n  hips: null,\n  spine: 'hips',\n  chest: 'spine',\n  upperChest: 'chest',\n  neck: 'upperChest',\n\n  head: 'neck',\n  leftEye: 'head',\n  rightEye: 'head',\n  jaw: 'head',\n\n  leftUpperLeg: 'hips',\n  leftLowerLeg: 'leftUpperLeg',\n  leftFoot: 'leftLowerLeg',\n  leftToes: 'leftFoot',\n\n  rightUpperLeg: 'hips',\n  rightLowerLeg: 'rightUpperLeg',\n  rightFoot: 'rightLowerLeg',\n  rightToes: 'rightFoot',\n\n  leftShoulder: 'upperChest',\n  leftUpperArm: 'leftShoulder',\n  leftLowerArm: 'leftUpperArm',\n  leftHand: 'leftLowerArm',\n\n  rightShoulder: 'upperChest',\n  rightUpperArm: 'rightShoulder',\n  rightLowerArm: 'rightUpperArm',\n  rightHand: 'rightLowerArm',\n\n  leftThumbMetacarpal: 'leftHand',\n  leftThumbProximal: 'leftThumbMetacarpal',\n  leftThumbDistal: 'leftThumbProximal',\n  leftIndexProximal: 'leftHand',\n  leftIndexIntermediate: 'leftIndexProximal',\n  leftIndexDistal: 'leftIndexIntermediate',\n  leftMiddleProximal: 'leftHand',\n  leftMiddleIntermediate: 'leftMiddleProximal',\n  leftMiddleDistal: 'leftMiddleIntermediate',\n  leftRingProximal: 'leftHand',\n  leftRingIntermediate: 'leftRingProximal',\n  leftRingDistal: 'leftRingIntermediate',\n  leftLittleProximal: 'leftHand',\n  leftLittleIntermediate: 'leftLittleProximal',\n  leftLittleDistal: 'leftLittleIntermediate',\n\n  rightThumbMetacarpal: 'rightHand',\n  rightThumbProximal: 'rightThumbMetacarpal',\n  rightThumbDistal: 'rightThumbProximal',\n  rightIndexProximal: 'rightHand',\n  rightIndexIntermediate: 'rightIndexProximal',\n  rightIndexDistal: 'rightIndexIntermediate',\n  rightMiddleProximal: 'rightHand',\n  rightMiddleIntermediate: 'rightMiddleProximal',\n  rightMiddleDistal: 'rightMiddleIntermediate',\n  rightRingProximal: 'rightHand',\n  rightRingIntermediate: 'rightRingProximal',\n  rightRingDistal: 'rightRingIntermediate',\n  rightLittleProximal: 'rightHand',\n  rightLittleIntermediate: 'rightLittleProximal',\n  rightLittleDistal: 'rightLittleIntermediate',\n};\n", "import * as THREE from 'three';\nimport { quatInvertCompat } from '../utils/quatInvertCompat';\nimport type { VRMHumanBone } from './VRMHumanBone';\nimport type { VRMHumanBones } from './VRMHumanBones';\nimport type { VRMHumanBoneName } from './VRMHumanBoneName';\nimport type { VRMPose } from './VRMPose';\n\nconst _v3A = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\n\n/**\n * A class represents the Rig of a VRM.\n */\nexport class VRMRig {\n  /**\n   * A {@link VRMHumanBones} that contains all the human bones of the VRM.\n   * You might want to get these bones using {@link VRMHumanoid.getBone}.\n   */\n  public humanBones: VRMHumanBones;\n\n  /**\n   * A {@link VRMPose} that is its default state.\n   * Note that it's not compatible with {@link setPose} and {@link getPose}, since it contains non-relative values of each local transforms.\n   */\n  public restPose: VRMPose;\n\n  /**\n   * Create a new {@link VRMHumanoid}.\n   * @param humanBones A {@link VRMHumanBones} contains all the bones of the new humanoid\n   */\n  public constructor(humanBones: VRMHumanBones) {\n    this.humanBones = humanBones;\n\n    this.restPose = this.getAbsolutePose();\n  }\n\n  /**\n   * Return the current absolute pose of this humanoid as a {@link VRMPose}.\n   * Note that the output result will contain initial state of the VRM and not compatible between different models.\n   * You might want to use {@link getPose} instead.\n   */\n  public getAbsolutePose(): VRMPose {\n    const pose = {} as VRMPose;\n\n    Object.keys(this.humanBones).forEach((vrmBoneNameString) => {\n      const vrmBoneName = vrmBoneNameString as VRMHumanBoneName;\n      const node = this.getBoneNode(vrmBoneName);\n\n      // Ignore when there are no bone on the VRMHumanoid\n      if (!node) {\n        return;\n      }\n\n      // Get the position / rotation from the node\n      _v3A.copy(node.position);\n      _quatA.copy(node.quaternion);\n\n      // Convert to raw arrays\n      pose[vrmBoneName] = {\n        position: _v3A.toArray() as [number, number, number],\n        rotation: _quatA.toArray() as [number, number, number, number],\n      };\n    });\n\n    return pose;\n  }\n\n  /**\n   * Return the current pose of this humanoid as a {@link VRMPose}.\n   *\n   * Each transform is a local transform relative from rest pose (T-pose).\n   */\n  public getPose(): VRMPose {\n    const pose = {} as VRMPose;\n\n    Object.keys(this.humanBones).forEach((boneNameString) => {\n      const boneName = boneNameString as VRMHumanBoneName;\n      const node = this.getBoneNode(boneName);\n\n      // Ignore when there are no bone on the VRMHumanoid\n      if (!node) {\n        return;\n      }\n\n      // Take a diff from restPose\n      _v3A.set(0, 0, 0);\n      _quatA.identity();\n\n      const restState = this.restPose[boneName];\n      if (restState?.position) {\n        _v3A.fromArray(restState.position).negate();\n      }\n      if (restState?.rotation) {\n        quatInvertCompat(_quatA.fromArray(restState.rotation));\n      }\n\n      // Get the position / rotation from the node\n      _v3A.add(node.position);\n      _quatA.premultiply(node.quaternion);\n\n      // Convert to raw arrays\n      pose[boneName] = {\n        position: _v3A.toArray() as [number, number, number],\n        rotation: _quatA.toArray() as [number, number, number, number],\n      };\n    });\n\n    return pose;\n  }\n\n  /**\n   * Let the humanoid do a specified pose.\n   *\n   * Each transform have to be a local transform relative from rest pose (T-pose).\n   * You can pass what you got from {@link getPose}.\n   *\n   * @param poseObject A {@link VRMPose} that represents a single pose\n   */\n  public setPose(poseObject: VRMPose): void {\n    Object.entries(poseObject).forEach(([boneNameString, state]) => {\n      const boneName = boneNameString as VRMHumanBoneName;\n      const node = this.getBoneNode(boneName);\n\n      // Ignore when there are no bone that is defined in the pose on the VRMHumanoid\n      if (!node) {\n        return;\n      }\n\n      const restState = this.restPose[boneName];\n      if (!restState) {\n        // It's very unlikely. Possibly a bug\n        return;\n      }\n\n      // Apply the state to the actual bone\n      if (state?.position) {\n        node.position.fromArray(state.position);\n\n        if (restState.position) {\n          node.position.add(_v3A.fromArray(restState.position));\n        }\n      }\n\n      if (state?.rotation) {\n        node.quaternion.fromArray(state.rotation);\n\n        if (restState.rotation) {\n          node.quaternion.multiply(_quatA.fromArray(restState.rotation));\n        }\n      }\n    });\n  }\n\n  /**\n   * Reset the humanoid to its rest pose.\n   */\n  public resetPose(): void {\n    Object.entries(this.restPose).forEach(([boneName, rest]) => {\n      const node = this.getBoneNode(boneName as VRMHumanBoneName);\n\n      if (!node) {\n        return;\n      }\n\n      if (rest?.position) {\n        node.position.fromArray(rest.position);\n      }\n\n      if (rest?.rotation) {\n        node.quaternion.fromArray(rest.rotation);\n      }\n    });\n  }\n\n  /**\n   * Return a bone bound to a specified {@link VRMHumanBoneName}, as a {@link VRMHumanBone}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getBone(name: VRMHumanBoneName): VRMHumanBone | undefined {\n    return this.humanBones[name] ?? undefined;\n  }\n\n  /**\n   * Return a bone bound to a specified {@link VRMHumanBoneName}, as a `THREE.Object3D`.\n   *\n   * @param name Name of the bone you want\n   */\n  public getBoneNode(name: VRMHumanBoneName): THREE.Object3D | null {\n    return this.humanBones[name]?.node ?? null;\n  }\n}\n", "import * as THREE from 'three';\n\n/**\n * A compat function for `Quaternion.invert()` / `Quaternion.inverse()`.\n * `Quaternion.invert()` is introduced in r123 and `Quaternion.inverse()` emits a warning.\n * We are going to use this compat for a while.\n * @param target A target quaternion\n */\nexport function quatInvertCompat<T extends THREE.Quaternion>(target: T): T {\n  if ((target as any).invert) {\n    target.invert();\n  } else {\n    (target as any).inverse();\n  }\n\n  return target;\n}\n", "import * as THREE from 'three';\nimport { VRMHumanBoneName, VRMHumanBones } from '.';\nimport { VRMHumanBoneList } from './VRMHumanBoneList';\nimport { VRMHumanBoneParentMap } from './VRMHumanBoneParentMap';\nimport { VRMRig } from './VRMRig';\n\nconst _v3A = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\nconst _boneWorldPos = new THREE.Vector3();\n\n/**\n * A class represents the normalized Rig of a VRM.\n */\nexport class VRMHumanoidRig extends VRMRig {\n  protected static _setupTransforms(modelRig: VRMRig): {\n    rigBones: VRMHumanBones;\n    root: THREE.Object3D;\n    parentWorldRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion };\n    boneRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion };\n  } {\n    const root = new THREE.Object3D();\n    root.name = 'VRMHumanoidRig';\n\n    // store boneWorldPositions, boneWorldRotations, and parentWorldRotations\n    const boneWorldPositions: { [boneName in VRMHumanBoneName]?: THREE.Vector3 } = {};\n    const boneWorldRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion } = {};\n    const boneRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion } = {};\n    const parentWorldRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion } = {};\n\n    VRMHumanBoneList.forEach((boneName) => {\n      const boneNode = modelRig.getBoneNode(boneName);\n\n      if (boneNode) {\n        const boneWorldPosition = new THREE.Vector3();\n        const boneWorldRotation = new THREE.Quaternion();\n\n        boneNode.updateWorldMatrix(true, false);\n        boneNode.matrixWorld.decompose(boneWorldPosition, boneWorldRotation, _v3A);\n\n        boneWorldPositions[boneName] = boneWorldPosition;\n        boneWorldRotations[boneName] = boneWorldRotation;\n        boneRotations[boneName] = boneNode.quaternion.clone();\n\n        const parentWorldRotation = new THREE.Quaternion();\n        boneNode.parent?.matrixWorld.decompose(_v3A, parentWorldRotation, _v3A);\n        parentWorldRotations[boneName] = parentWorldRotation;\n      }\n    });\n\n    // build rig hierarchy + store parentWorldRotations\n    const rigBones: Partial<VRMHumanBones> = {};\n    VRMHumanBoneList.forEach((boneName) => {\n      const boneNode = modelRig.getBoneNode(boneName);\n\n      if (boneNode) {\n        const boneWorldPosition = boneWorldPositions[boneName] as THREE.Vector3;\n\n        // see the nearest parent position\n        let currentBoneName: VRMHumanBoneName | null = boneName;\n        let parentBoneWorldPosition: THREE.Vector3 | undefined;\n        while (parentBoneWorldPosition == null) {\n          currentBoneName = VRMHumanBoneParentMap[currentBoneName];\n          if (currentBoneName == null) {\n            break;\n          }\n          parentBoneWorldPosition = boneWorldPositions[currentBoneName];\n        }\n\n        // add to hierarchy\n        const rigBoneNode = new THREE.Object3D();\n        rigBoneNode.name = 'Normalized_' + boneNode.name;\n\n        const parentRigBoneNode = (currentBoneName ? rigBones[currentBoneName]?.node : root) as THREE.Object3D;\n\n        parentRigBoneNode.add(rigBoneNode);\n        rigBoneNode.position.copy(boneWorldPosition);\n        if (parentBoneWorldPosition) {\n          rigBoneNode.position.sub(parentBoneWorldPosition);\n        }\n\n        rigBones[boneName] = { node: rigBoneNode };\n      }\n    });\n\n    return {\n      rigBones: rigBones as VRMHumanBones,\n      root,\n      parentWorldRotations,\n      boneRotations,\n    };\n  }\n\n  public readonly original: VRMRig;\n  public readonly root: THREE.Object3D;\n  protected readonly _parentWorldRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion };\n  protected readonly _boneRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion };\n\n  public constructor(humanoid: VRMRig) {\n    const { rigBones, root, parentWorldRotations, boneRotations } = VRMHumanoidRig._setupTransforms(humanoid);\n\n    super(rigBones);\n\n    this.original = humanoid;\n    this.root = root;\n    this._parentWorldRotations = parentWorldRotations;\n    this._boneRotations = boneRotations;\n  }\n\n  /**\n   * Update this humanoid rig.\n   */\n  public update(): void {\n    VRMHumanBoneList.forEach((boneName) => {\n      const boneNode = this.original.getBoneNode(boneName);\n\n      if (boneNode != null) {\n        const rigBoneNode = this.getBoneNode(boneName)!;\n        const parentWorldRotation = this._parentWorldRotations[boneName]!;\n        const invParentWorldRotation = _quatA.copy(parentWorldRotation).invert();\n        const boneRotation = this._boneRotations[boneName]!;\n\n        boneNode.quaternion\n          .copy(rigBoneNode.quaternion)\n          .multiply(parentWorldRotation)\n          .premultiply(invParentWorldRotation)\n          .multiply(boneRotation);\n\n        // Move the mass center of the VRM\n        if (boneName === 'hips') {\n          const boneWorldPosition = rigBoneNode.getWorldPosition(_boneWorldPos);\n          boneNode.parent!.updateWorldMatrix(true, false);\n          const parentWorldMatrix = boneNode.parent!.matrixWorld;\n          const localPosition = boneWorldPosition.applyMatrix4(parentWorldMatrix.invert());\n          boneNode.position.copy(localPosition);\n        }\n      }\n    });\n  }\n}\n", "import * as THREE from 'three';\nimport type { VRMHumanBone } from './VRMHumanBone';\nimport type { VRMHumanBones } from './VRMHumanBones';\nimport type { VRMHumanBoneName } from './VRMHumanBoneName';\nimport type { VRMPose } from './VRMPose';\nimport { VRMRig } from './VRMRig';\nimport { VRMHumanoidRig } from './VRMHumanoidRig';\n\n/**\n * A class represents a humanoid of a VRM.\n */\nexport class VRMHumanoid {\n  /**\n   * Whether it copies pose from normalizedHumanBones to rawHumanBones on {@link update}.\n   * `true` by default.\n   *\n   * @default true\n   */\n  public autoUpdateHumanBones: boolean;\n\n  /**\n   * A raw rig of the VRM.\n   */\n  private _rawHumanBones: VRMRig; // TODO: Rename\n\n  /**\n   * A normalized rig of the VRM.\n   */\n  private _normalizedHumanBones: VRMHumanoidRig; // TODO: Rename\n\n  /**\n   * @deprecated Deprecated. Use either {@link rawRestPose} or {@link normalizedRestPose} instead.\n   */\n  public get restPose(): VRMPose {\n    console.warn('VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead.');\n\n    return this.rawRestPose;\n  }\n\n  /**\n   * A {@link VRMPose} of its raw human bones that is its default state.\n   * Note that it's not compatible with {@link setRawPose} and {@link getRawPose}, since it contains non-relative values of each local transforms.\n   */\n  public get rawRestPose(): VRMPose {\n    return this._rawHumanBones.restPose;\n  }\n\n  /**\n   * A {@link VRMPose} of its normalized human bones that is its default state.\n   * Note that it's not compatible with {@link setNormalizedPose} and {@link getNormalizedPose}, since it contains non-relative values of each local transforms.\n   */\n  public get normalizedRestPose(): VRMPose {\n    return this._normalizedHumanBones.restPose;\n  }\n\n  /**\n   * A map from {@link VRMHumanBoneName} to raw {@link VRMHumanBone}s.\n   */\n  public get humanBones(): VRMHumanBones {\n    // an alias of `rawHumanBones`\n    return this._rawHumanBones.humanBones;\n  }\n\n  /**\n   * A map from {@link VRMHumanBoneName} to raw {@link VRMHumanBone}s.\n   */\n  public get rawHumanBones(): VRMHumanBones {\n    return this._rawHumanBones.humanBones;\n  }\n\n  /**\n   * A map from {@link VRMHumanBoneName} to normalized {@link VRMHumanBone}s.\n   */\n  public get normalizedHumanBones(): VRMHumanBones {\n    return this._normalizedHumanBones.humanBones;\n  }\n\n  /**\n   * The root of normalized {@link VRMHumanBone}s.\n   */\n  public get normalizedHumanBonesRoot(): THREE.Object3D {\n    return this._normalizedHumanBones.root;\n  }\n\n  /**\n   * Create a new {@link VRMHumanoid}.\n   * @param humanBones A {@link VRMHumanBones} contains all the bones of the new humanoid\n   * @param autoUpdateHumanBones Whether it copies pose from normalizedHumanBones to rawHumanBones on {@link update}. `true` by default.\n   */\n  public constructor(humanBones: VRMHumanBones, options?: { autoUpdateHumanBones?: boolean }) {\n    this.autoUpdateHumanBones = options?.autoUpdateHumanBones ?? true;\n    this._rawHumanBones = new VRMRig(humanBones);\n    this._normalizedHumanBones = new VRMHumanoidRig(this._rawHumanBones);\n  }\n\n  /**\n   * Copy the given {@link VRMHumanoid} into this one.\n   * @param source The {@link VRMHumanoid} you want to copy\n   * @returns this\n   */\n  public copy(source: VRMHumanoid): this {\n    this.autoUpdateHumanBones = source.autoUpdateHumanBones;\n    this._rawHumanBones = new VRMRig(source.humanBones);\n    this._normalizedHumanBones = new VRMHumanoidRig(this._rawHumanBones);\n\n    return this;\n  }\n\n  /**\n   * Returns a clone of this {@link VRMHumanoid}.\n   * @returns Copied {@link VRMHumanoid}\n   */\n  public clone(): VRMHumanoid {\n    return new VRMHumanoid(this.humanBones, { autoUpdateHumanBones: this.autoUpdateHumanBones }).copy(this);\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link getRawAbsolutePose} or {@link getNormalizedAbsolutePose} instead.\n   */\n  public getAbsolutePose(): VRMPose {\n    console.warn(\n      'VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead.',\n    );\n\n    return this.getRawAbsolutePose();\n  }\n\n  /**\n   * Return the current absolute pose of this raw human bones as a {@link VRMPose}.\n   * Note that the output result will contain initial state of the VRM and not compatible between different models.\n   * You might want to use {@link getRawPose} instead.\n   */\n  public getRawAbsolutePose(): VRMPose {\n    return this._rawHumanBones.getAbsolutePose();\n  }\n\n  /**\n   * Return the current absolute pose of this normalized human bones as a {@link VRMPose}.\n   * Note that the output result will contain initial state of the VRM and not compatible between different models.\n   * You might want to use {@link getNormalizedPose} instead.\n   */\n  public getNormalizedAbsolutePose(): VRMPose {\n    return this._normalizedHumanBones.getAbsolutePose();\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link getRawPose} or {@link getNormalizedPose} instead.\n   */\n  public getPose(): VRMPose {\n    console.warn('VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead.');\n\n    return this.getRawPose();\n  }\n\n  /**\n   * Return the current pose of raw human bones as a {@link VRMPose}.\n   *\n   * Each transform is a local transform relative from rest pose (T-pose).\n   */\n  public getRawPose(): VRMPose {\n    return this._rawHumanBones.getPose();\n  }\n\n  /**\n   * Return the current pose of normalized human bones as a {@link VRMPose}.\n   *\n   * Each transform is a local transform relative from rest pose (T-pose).\n   */\n  public getNormalizedPose(): VRMPose {\n    return this._normalizedHumanBones.getPose();\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link setRawPose} or {@link setNormalizedPose} instead.\n   */\n  public setPose(poseObject: VRMPose): void {\n    console.warn('VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead.');\n\n    return this.setRawPose(poseObject);\n  }\n\n  /**\n   * Let the raw human bones do a specified pose.\n   *\n   * Each transform have to be a local transform relative from rest pose (T-pose).\n   * You can pass what you got from {@link getRawPose}.\n   *\n   * If you are using {@link autoUpdateHumanBones}, you might want to use {@link setNormalizedPose} instead.\n   *\n   * @param poseObject A {@link VRMPose} that represents a single pose\n   */\n  public setRawPose(poseObject: VRMPose): void {\n    return this._rawHumanBones.setPose(poseObject);\n  }\n\n  /**\n   * Let the normalized human bones do a specified pose.\n   *\n   * Each transform have to be a local transform relative from rest pose (T-pose).\n   * You can pass what you got from {@link getNormalizedPose}.\n   *\n   * @param poseObject A {@link VRMPose} that represents a single pose\n   */\n  public setNormalizedPose(poseObject: VRMPose): void {\n    return this._normalizedHumanBones.setPose(poseObject);\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link resetRawPose} or {@link resetNormalizedPose} instead.\n   */\n  public resetPose(): void {\n    console.warn('VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead.');\n\n    return this.resetRawPose();\n  }\n\n  /**\n   * Reset the raw humanoid to its rest pose.\n   *\n   * If you are using {@link autoUpdateHumanBones}, you might want to use {@link resetNormalizedPose} instead.\n   */\n  public resetRawPose(): void {\n    return this._rawHumanBones.resetPose();\n  }\n\n  /**\n   * Reset the normalized humanoid to its rest pose.\n   */\n  public resetNormalizedPose(): void {\n    return this._normalizedHumanBones.resetPose();\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link getRawBone} or {@link getNormalizedBone} instead.\n   */\n  public getBone(name: VRMHumanBoneName): VRMHumanBone | undefined {\n    console.warn('VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead.');\n\n    return this.getRawBone(name);\n  }\n\n  /**\n   * Return a raw {@link VRMHumanBone} bound to a specified {@link VRMHumanBoneName}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getRawBone(name: VRMHumanBoneName): VRMHumanBone | undefined {\n    return this._rawHumanBones.getBone(name);\n  }\n\n  /**\n   * Return a normalized {@link VRMHumanBone} bound to a specified {@link VRMHumanBoneName}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getNormalizedBone(name: VRMHumanBoneName): VRMHumanBone | undefined {\n    return this._normalizedHumanBones.getBone(name);\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link getRawBoneNode} or {@link getNormalizedBoneNode} instead.\n   */\n  public getBoneNode(name: VRMHumanBoneName): THREE.Object3D | null {\n    console.warn(\n      'VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead.',\n    );\n\n    return this.getRawBoneNode(name);\n  }\n\n  /**\n   * Return a raw bone as a `THREE.Object3D` bound to a specified {@link VRMHumanBoneName}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getRawBoneNode(name: VRMHumanBoneName): THREE.Object3D | null {\n    return this._rawHumanBones.getBoneNode(name);\n  }\n\n  /**\n   * Return a normalized bone as a `THREE.Object3D` bound to a specified {@link VRMHumanBoneName}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getNormalizedBoneNode(name: VRMHumanBoneName): THREE.Object3D | null {\n    return this._normalizedHumanBones.getBoneNode(name);\n  }\n\n  /**\n   * Update the humanoid component.\n   *\n   * If {@link autoUpdateHumanBones} is `true`, it transfers the pose of normalized human bones to raw human bones.\n   */\n  public update(): void {\n    if (this.autoUpdateHumanBones) {\n      this._normalizedHumanBones.update();\n    }\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMRequiredHumanBoneName = {\n  Hips: 'hips',\n  Spine: 'spine',\n  Head: 'head',\n  LeftUpperLeg: 'leftUpperLeg',\n  LeftLowerLeg: 'leftLowerLeg',\n  LeftFoot: 'leftFoot',\n  RightUpperLeg: 'rightUpperLeg',\n  RightLowerLeg: 'rightLowerLeg',\n  RightFoot: 'rightFoot',\n  LeftUpperArm: 'leftUpperArm',\n  LeftLowerArm: 'leftLowerArm',\n  LeftHand: 'leftHand',\n  RightUpperArm: 'rightUpperArm',\n  RightLowerArm: 'rightLowerArm',\n  RightHand: 'rightHand',\n} as const;\n\nexport type VRMRequiredHumanBoneName = (typeof VRMRequiredHumanBoneName)[keyof typeof VRMRequiredHumanBoneName];\n", "import type * as THREE from 'three';\nimport type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { VRMHumanoid } from './VRMHumanoid';\nimport type { VRMHumanBones } from './VRMHumanBones';\nimport { VRMRequiredHumanBoneName } from './VRMRequiredHumanBoneName';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\nimport { VRMHumanoidHelper } from './helpers/VRMHumanoidHelper';\nimport { VRMHumanoidLoaderPluginOptions } from './VRMHumanoidLoaderPluginOptions';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * A map from old thumb bone names to new thumb bone names\n */\nconst thumbBoneNameMap: { [key: string]: V1VRMSchema.HumanoidHumanBoneName | undefined } = {\n  leftThumbProximal: 'leftThumbMetacarpal',\n  leftThumbIntermediate: 'leftThumbProximal',\n  rightThumbProximal: 'rightThumbMetacarpal',\n  rightThumbIntermediate: 'rightThumbProximal',\n};\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRMHumanoid} from a VRM extension of a GLTF.\n */\nexport class VRMHumanoidLoaderPlugin implements GLTFLoaderPlugin {\n  /**\n   * Specify an Object3D to add {@link VRMHumanoidHelper}.\n   * If not specified, helper will not be created.\n   * If `renderOrder` is set to the root, the helper will copy the same `renderOrder` .\n   */\n  public helperRoot?: THREE.Object3D;\n\n  public autoUpdateHumanBones?: boolean;\n\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMHumanoidLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser, options?: VRMHumanoidLoaderPluginOptions) {\n    this.parser = parser;\n\n    this.helperRoot = options?.helperRoot;\n    this.autoUpdateHumanBones = options?.autoUpdateHumanBones;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    gltf.userData.vrmHumanoid = await this._import(gltf);\n  }\n\n  /**\n   * Import a {@link VRMHumanoid} from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  private async _import(gltf: GLTF): Promise<VRMHumanoid | null> {\n    const v1Result = await this._v1Import(gltf);\n    if (v1Result) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf);\n    if (v0Result) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(gltf: GLTF): Promise<VRMHumanoid | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (!extension) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaHumanoid = extension.humanoid;\n    if (!schemaHumanoid) {\n      return null;\n    }\n\n    /**\n     * compat: 1.0-beta thumb bone names\n     *\n     * `true` if `leftThumbIntermediate` or `rightThumbIntermediate` exists\n     */\n    const existsPreviousThumbName =\n      (schemaHumanoid.humanBones as any).leftThumbIntermediate != null ||\n      (schemaHumanoid.humanBones as any).rightThumbIntermediate != null;\n\n    const humanBones: Partial<VRMHumanBones> = {};\n    if (schemaHumanoid.humanBones != null) {\n      await Promise.all(\n        Object.entries(schemaHumanoid.humanBones).map(async ([boneNameString, schemaHumanBone]) => {\n          let boneName = boneNameString as V1VRMSchema.HumanoidHumanBoneName;\n          const index = schemaHumanBone.node;\n\n          // compat: 1.0-beta previous thumb bone names\n          if (existsPreviousThumbName) {\n            const thumbBoneName = thumbBoneNameMap[boneName];\n            if (thumbBoneName != null) {\n              boneName = thumbBoneName;\n            }\n          }\n\n          const node = await this.parser.getDependency('node', index);\n\n          // if the specified node does not exist, emit a warning\n          if (node == null) {\n            console.warn(`A glTF node bound to the humanoid bone ${boneName} (index = ${index}) does not exist`);\n            return;\n          }\n\n          // set to the `humanBones`\n          humanBones[boneName] = { node };\n        }),\n      );\n    }\n\n    const humanoid = new VRMHumanoid(this._ensureRequiredBonesExist(humanBones), {\n      autoUpdateHumanBones: this.autoUpdateHumanBones,\n    });\n    gltf.scene.add(humanoid.normalizedHumanBonesRoot);\n\n    if (this.helperRoot) {\n      const helper = new VRMHumanoidHelper(humanoid);\n      this.helperRoot.add(helper);\n      helper.renderOrder = this.helperRoot.renderOrder;\n    }\n\n    return humanoid;\n  }\n\n  private async _v0Import(gltf: GLTF): Promise<VRMHumanoid | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaHumanoid: V0VRM.Humanoid | undefined = vrmExt.humanoid;\n    if (!schemaHumanoid) {\n      return null;\n    }\n\n    const humanBones: Partial<VRMHumanBones> = {};\n    if (schemaHumanoid.humanBones != null) {\n      await Promise.all(\n        schemaHumanoid.humanBones.map(async (bone) => {\n          const boneName = bone.bone;\n          const index = bone.node;\n\n          if (boneName == null || index == null) {\n            return;\n          }\n\n          const node = await this.parser.getDependency('node', index);\n\n          // if the specified node does not exist, emit a warning\n          if (node == null) {\n            console.warn(`A glTF node bound to the humanoid bone ${boneName} (index = ${index}) does not exist`);\n            return;\n          }\n\n          // map to new bone name\n          const thumbBoneName = thumbBoneNameMap[boneName];\n          const newBoneName = (thumbBoneName ?? boneName) as V1VRMSchema.HumanoidHumanBoneName;\n\n          // v0 VRMs might have a multiple nodes attached to a single bone...\n          // so if there already is an entry in the `humanBones`, show a warning and ignore it\n          if (humanBones[newBoneName] != null) {\n            console.warn(\n              `Multiple bone entries for ${newBoneName} detected (index = ${index}), ignoring duplicated entries.`,\n            );\n            return;\n          }\n\n          // set to the `humanBones`\n          humanBones[newBoneName] = { node };\n        }),\n      );\n    }\n\n    const humanoid = new VRMHumanoid(this._ensureRequiredBonesExist(humanBones), {\n      autoUpdateHumanBones: this.autoUpdateHumanBones,\n    });\n    gltf.scene.add(humanoid.normalizedHumanBonesRoot);\n\n    if (this.helperRoot) {\n      const helper = new VRMHumanoidHelper(humanoid);\n      this.helperRoot.add(helper);\n      helper.renderOrder = this.helperRoot.renderOrder;\n    }\n\n    return humanoid;\n  }\n\n  /**\n   * Ensure required bones exist in given human bones.\n   * @param humanBones Human bones\n   * @returns Human bones, no longer partial!\n   */\n  private _ensureRequiredBonesExist(humanBones: Partial<VRMHumanBones>): VRMHumanBones {\n    // ensure required bones exist\n    const missingRequiredBones = Object.values(VRMRequiredHumanBoneName).filter(\n      (requiredBoneName) => humanBones[requiredBoneName] == null,\n    );\n\n    // throw an error if there are missing bones\n    if (missingRequiredBones.length > 0) {\n      throw new Error(\n        `VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${missingRequiredBones.join(', ')}`,\n      );\n    }\n\n    return humanBones as VRMHumanBones;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMLookAt } from '../VRMLookAt';\nimport { FanBufferGeometry } from './utils/FanBufferGeometry';\nimport { LineAndSphereBufferGeometry } from './utils/LineAndSphereBufferGeometry';\n\nconst _quatA = new THREE.Quaternion();\nconst _quatB = new THREE.Quaternion();\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\n\nconst SQRT_2_OVER_2 = Math.sqrt(2.0) / 2.0;\nconst QUAT_XY_CW90 = new THREE.Quaternion(0, 0, -SQRT_2_OVER_2, SQRT_2_OVER_2);\nconst VEC3_POSITIVE_Y = new THREE.Vector3(0.0, 1.0, 0.0);\n\nexport class VRMLookAtHelper extends THREE.Group {\n  public readonly vrmLookAt: VRMLookAt;\n  private readonly _meshYaw: THREE.Mesh<FanBufferGeometry, THREE.MeshBasicMaterial>;\n  private readonly _meshPitch: THREE.Mesh<FanBufferGeometry, THREE.MeshBasicMaterial>;\n  private readonly _lineTarget: THREE.LineSegments<LineAndSphereBufferGeometry, THREE.LineBasicMaterial>;\n\n  public constructor(lookAt: VRMLookAt) {\n    super();\n    this.matrixAutoUpdate = false;\n\n    this.vrmLookAt = lookAt;\n\n    {\n      const geometry = new FanBufferGeometry();\n      geometry.radius = 0.5;\n\n      const material = new THREE.MeshBasicMaterial({\n        color: 0x00ff00,\n        transparent: true,\n        opacity: 0.5,\n        side: THREE.DoubleSide,\n        depthTest: false,\n        depthWrite: false,\n      });\n\n      this._meshPitch = new THREE.Mesh(geometry, material);\n      this.add(this._meshPitch);\n    }\n\n    {\n      const geometry = new FanBufferGeometry();\n      geometry.radius = 0.5;\n\n      const material = new THREE.MeshBasicMaterial({\n        color: 0xff0000,\n        transparent: true,\n        opacity: 0.5,\n        side: THREE.DoubleSide,\n        depthTest: false,\n        depthWrite: false,\n      });\n\n      this._meshYaw = new THREE.Mesh(geometry, material);\n      this.add(this._meshYaw);\n    }\n\n    {\n      const geometry = new LineAndSphereBufferGeometry();\n      geometry.radius = 0.1;\n\n      const material = new THREE.LineBasicMaterial({\n        color: 0xffffff,\n        depthTest: false,\n        depthWrite: false,\n      });\n\n      this._lineTarget = new THREE.LineSegments(geometry, material);\n      this._lineTarget.frustumCulled = false;\n      this.add(this._lineTarget);\n    }\n  }\n\n  public dispose(): void {\n    this._meshYaw.geometry.dispose();\n    this._meshYaw.material.dispose();\n\n    this._meshPitch.geometry.dispose();\n    this._meshPitch.material.dispose();\n\n    this._lineTarget.geometry.dispose();\n    this._lineTarget.material.dispose();\n  }\n\n  public updateMatrixWorld(force: boolean): void {\n    // update geometries\n    const yaw = THREE.MathUtils.DEG2RAD * this.vrmLookAt.yaw;\n    this._meshYaw.geometry.theta = yaw;\n    this._meshYaw.geometry.update();\n\n    const pitch = THREE.MathUtils.DEG2RAD * this.vrmLookAt.pitch;\n    this._meshPitch.geometry.theta = pitch;\n    this._meshPitch.geometry.update();\n\n    // get world position and quaternion\n    this.vrmLookAt.getLookAtWorldPosition(_v3A);\n    this.vrmLookAt.getLookAtWorldQuaternion(_quatA);\n\n    // calculate rotation using faceFront\n    _quatA.multiply(this.vrmLookAt.getFaceFrontQuaternion(_quatB));\n\n    // set transform to meshes\n    this._meshYaw.position.copy(_v3A);\n    this._meshYaw.quaternion.copy(_quatA);\n\n    this._meshPitch.position.copy(_v3A);\n    this._meshPitch.quaternion.copy(_quatA);\n    this._meshPitch.quaternion.multiply(_quatB.setFromAxisAngle(VEC3_POSITIVE_Y, yaw));\n    this._meshPitch.quaternion.multiply(QUAT_XY_CW90);\n\n    // update target line and sphere\n    const { target, autoUpdate } = this.vrmLookAt;\n    if (target != null && autoUpdate) {\n      target.getWorldPosition(_v3B).sub(_v3A);\n      this._lineTarget.geometry.tail.copy(_v3B);\n      this._lineTarget.geometry.update();\n      this._lineTarget.position.copy(_v3A);\n    }\n\n    // apply transform to meshes\n    super.updateMatrixWorld(force);\n  }\n}\n", "import * as THREE from 'three';\n\nexport class FanBufferGeometry extends THREE.BufferGeometry {\n  public theta: number;\n  public radius: number;\n  private _currentTheta = 0;\n  private _currentRadius = 0;\n  private readonly _attrPos: THREE.BufferAttribute;\n  private readonly _attrIndex: THREE.BufferAttribute;\n\n  public constructor() {\n    super();\n\n    this.theta = 0.0;\n    this.radius = 0.0;\n    this._currentTheta = 0.0;\n    this._currentRadius = 0.0;\n\n    this._attrPos = new THREE.BufferAttribute(new Float32Array(65 * 3), 3);\n    this.setAttribute('position', this._attrPos);\n\n    this._attrIndex = new THREE.BufferAttribute(new Uint16Array(3 * 63), 1);\n    this.setIndex(this._attrIndex);\n\n    this._buildIndex();\n    this.update();\n  }\n\n  public update(): void {\n    let shouldUpdateGeometry = false;\n\n    if (this._currentTheta !== this.theta) {\n      this._currentTheta = this.theta;\n      shouldUpdateGeometry = true;\n    }\n\n    if (this._currentRadius !== this.radius) {\n      this._currentRadius = this.radius;\n      shouldUpdateGeometry = true;\n    }\n\n    if (shouldUpdateGeometry) {\n      this._buildPosition();\n    }\n  }\n\n  private _buildPosition(): void {\n    this._attrPos.setXYZ(0, 0.0, 0.0, 0.0);\n\n    for (let i = 0; i < 64; i++) {\n      const t = (i / 63.0) * this._currentTheta;\n\n      this._attrPos.setXYZ(i + 1, this._currentRadius * Math.sin(t), 0.0, this._currentRadius * Math.cos(t));\n    }\n\n    this._attrPos.needsUpdate = true;\n  }\n\n  private _buildIndex(): void {\n    for (let i = 0; i < 63; i++) {\n      this._attrIndex.setXYZ(i * 3, 0, i + 1, i + 2);\n    }\n\n    this._attrIndex.needsUpdate = true;\n  }\n}\n", "import * as THREE from 'three';\n\nexport class LineAndSphereBufferGeometry extends THREE.BufferGeometry {\n  public radius: number;\n  public tail: THREE.Vector3;\n  private _currentRadius: number;\n  private _currentTail: THREE.Vector3;\n  private readonly _attrPos: THREE.BufferAttribute;\n  private readonly _attrIndex: THREE.BufferAttribute;\n\n  public constructor() {\n    super();\n\n    this.radius = 0.0;\n    this._currentRadius = 0.0;\n\n    this.tail = new THREE.Vector3();\n    this._currentTail = new THREE.Vector3();\n\n    this._attrPos = new THREE.BufferAttribute(new Float32Array(294), 3);\n    this.setAttribute('position', this._attrPos);\n\n    this._attrIndex = new THREE.BufferAttribute(new Uint16Array(194), 1);\n    this.setIndex(this._attrIndex);\n\n    this._buildIndex();\n    this.update();\n  }\n\n  public update(): void {\n    let shouldUpdateGeometry = false;\n\n    if (this._currentRadius !== this.radius) {\n      this._currentRadius = this.radius;\n      shouldUpdateGeometry = true;\n    }\n\n    if (!this._currentTail.equals(this.tail)) {\n      this._currentTail.copy(this.tail);\n      shouldUpdateGeometry = true;\n    }\n\n    if (shouldUpdateGeometry) {\n      this._buildPosition();\n    }\n  }\n\n  private _buildPosition(): void {\n    for (let i = 0; i < 32; i++) {\n      const t = (i / 16.0) * Math.PI;\n\n      this._attrPos.setXYZ(i, Math.cos(t), Math.sin(t), 0.0);\n      this._attrPos.setXYZ(32 + i, 0.0, Math.cos(t), Math.sin(t));\n      this._attrPos.setXYZ(64 + i, Math.sin(t), 0.0, Math.cos(t));\n    }\n\n    this.scale(this._currentRadius, this._currentRadius, this._currentRadius);\n    this.translate(this._currentTail.x, this._currentTail.y, this._currentTail.z);\n\n    this._attrPos.setXYZ(96, 0, 0, 0);\n    this._attrPos.setXYZ(97, this._currentTail.x, this._currentTail.y, this._currentTail.z);\n\n    this._attrPos.needsUpdate = true;\n  }\n\n  private _buildIndex(): void {\n    for (let i = 0; i < 32; i++) {\n      const i1 = (i + 1) % 32;\n\n      this._attrIndex.setXY(i * 2, i, i1);\n      this._attrIndex.setXY(64 + i * 2, 32 + i, 32 + i1);\n      this._attrIndex.setXY(128 + i * 2, 64 + i, 64 + i1);\n    }\n    this._attrIndex.setXY(192, 96, 97);\n\n    this._attrIndex.needsUpdate = true;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMHumanoid } from '../humanoid';\nimport { getWorldQuaternionLite } from '../utils/getWorldQuaternionLite';\nimport { quatInvertCompat } from '../utils/quatInvertCompat';\nimport { calcAzimuthAltitude } from './utils/calcAzimuthAltitude';\nimport type { VRMLookAtApplier } from './VRMLookAtApplier';\nimport { sanitizeAngle } from './utils/sanitizeAngle';\n\nconst VEC3_POSITIVE_Z = new THREE.Vector3(0.0, 0.0, 1.0);\n\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\nconst _v3C = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\nconst _quatB = new THREE.Quaternion();\nconst _quatC = new THREE.Quaternion();\nconst _quatD = new THREE.Quaternion();\nconst _eulerA = new THREE.Euler();\n\n/**\n * A class controls eye gaze movements of a VRM.\n */\nexport class VRMLookAt {\n  public static readonly EULER_ORDER = 'YXZ'; // yaw-pitch-roll\n\n  /**\n   * The origin of LookAt. Position offset from the head bone.\n   */\n  public offsetFromHeadBone = new THREE.Vector3();\n\n  /**\n   * Its associated {@link VRMHumanoid}.\n   */\n  public readonly humanoid: VRMHumanoid;\n\n  /**\n   * The {@link VRMLookAtApplier} of the LookAt.\n   */\n  public applier: VRMLookAtApplier;\n\n  /**\n   * If this is true, the LookAt will be updated automatically by calling {@link update}, towarding the direction to the {@link target}.\n   * `true` by default.\n   *\n   * See also: {@link target}\n   */\n  public autoUpdate = true;\n\n  /**\n   * The target object of the LookAt.\n   * Note that it does not make any sense if {@link autoUpdate} is disabled.\n   *\n   * See also: {@link autoUpdate}\n   */\n  public target?: THREE.Object3D | null;\n\n  /**\n   * The front direction of the face.\n   * Intended to be used for VRM 0.0 compat (VRM 0.0 models are facing Z- instead of Z+).\n   * You usually don't want to touch this.\n   */\n  public faceFront = new THREE.Vector3(0.0, 0.0, 1.0);\n\n  /**\n   * Its current angle around Y axis, in degree.\n   */\n  protected _yaw: number;\n\n  /**\n   * Its current angle around Y axis, in degree.\n   */\n  public get yaw(): number {\n    return this._yaw;\n  }\n\n  /**\n   * Its current angle around Y axis, in degree.\n   */\n  public set yaw(value: number) {\n    this._yaw = value;\n    this._needsUpdate = true;\n  }\n\n  /**\n   * Its current angle around X axis, in degree.\n   */\n  protected _pitch: number;\n\n  /**\n   * Its current angle around X axis, in degree.\n   */\n  public get pitch(): number {\n    return this._pitch;\n  }\n\n  /**\n   * Its current angle around X axis, in degree.\n   */\n  public set pitch(value: number) {\n    this._pitch = value;\n    this._needsUpdate = true;\n  }\n\n  /**\n   * Specifies that angles need to be applied to its [@link applier].\n   */\n  protected _needsUpdate: boolean;\n\n  /**\n   * World rotation of the head in its rest pose.\n   */\n  private _restHeadWorldQuaternion: THREE.Quaternion;\n\n  /**\n   * @deprecated Use {@link getEuler} instead.\n   */\n  public get euler(): THREE.Euler {\n    console.warn('VRMLookAt: euler is deprecated. use getEuler() instead.');\n\n    return this.getEuler(new THREE.Euler());\n  }\n\n  /**\n   * Create a new {@link VRMLookAt}.\n   *\n   * @param humanoid A {@link VRMHumanoid}\n   * @param applier A {@link VRMLookAtApplier}\n   */\n  public constructor(humanoid: VRMHumanoid, applier: VRMLookAtApplier) {\n    this.humanoid = humanoid;\n    this.applier = applier;\n\n    this._yaw = 0.0;\n    this._pitch = 0.0;\n    this._needsUpdate = true;\n\n    this._restHeadWorldQuaternion = this.getLookAtWorldQuaternion(new THREE.Quaternion());\n  }\n\n  /**\n   * Get its yaw-pitch angles as an `Euler`.\n   * Does NOT consider {@link faceFront}; it returns `Euler(0, 0, 0; \"YXZ\")` by default regardless of the faceFront value.\n   *\n   * @param target The target euler\n   */\n  public getEuler(target: THREE.Euler): THREE.Euler {\n    return target.set(THREE.MathUtils.DEG2RAD * this._pitch, THREE.MathUtils.DEG2RAD * this._yaw, 0.0, 'YXZ');\n  }\n\n  /**\n   * Copy the given {@link VRMLookAt} into this one.\n   * {@link humanoid} must be same as the source one.\n   * {@link applier} will reference the same instance as the source one.\n   * @param source The {@link VRMLookAt} you want to copy\n   * @returns this\n   */\n  public copy(source: VRMLookAt): this {\n    if (this.humanoid !== source.humanoid) {\n      throw new Error('VRMLookAt: humanoid must be same in order to copy');\n    }\n\n    this.offsetFromHeadBone.copy(source.offsetFromHeadBone);\n    this.applier = source.applier;\n    this.autoUpdate = source.autoUpdate;\n    this.target = source.target;\n    this.faceFront.copy(source.faceFront);\n\n    return this;\n  }\n\n  /**\n   * Returns a clone of this {@link VRMLookAt}.\n   * Note that {@link humanoid} and {@link applier} will reference the same instance as this one.\n   * @returns Copied {@link VRMLookAt}\n   */\n  public clone(): VRMLookAt {\n    return new VRMLookAt(this.humanoid, this.applier).copy(this);\n  }\n\n  /**\n   * Reset the lookAt direction (yaw and pitch) to the initial direction.\n   */\n  public reset(): void {\n    this._yaw = 0.0;\n    this._pitch = 0.0;\n    this._needsUpdate = true;\n  }\n\n  /**\n   * Get its lookAt position in world coordinate.\n   *\n   * @param target A target `THREE.Vector3`\n   */\n  public getLookAtWorldPosition(target: THREE.Vector3): THREE.Vector3 {\n    const head = this.humanoid.getRawBoneNode('head')!;\n\n    return target.copy(this.offsetFromHeadBone).applyMatrix4(head.matrixWorld);\n  }\n\n  /**\n   * Get its lookAt rotation in world coordinate.\n   * Does NOT consider {@link faceFront}.\n   *\n   * @param target A target `THREE.Quaternion`\n   */\n  public getLookAtWorldQuaternion(target: THREE.Quaternion): THREE.Quaternion {\n    const head = this.humanoid.getRawBoneNode('head')!;\n\n    return getWorldQuaternionLite(head, target);\n  }\n\n  /**\n   * Get a quaternion that rotates the +Z unit vector of the humanoid Head to the {@link faceFront} direction.\n   *\n   * @param target A target `THREE.Quaternion`\n   */\n  public getFaceFrontQuaternion(target: THREE.Quaternion): THREE.Quaternion {\n    if (this.faceFront.distanceToSquared(VEC3_POSITIVE_Z) < 0.01) {\n      return target.copy(this._restHeadWorldQuaternion).invert();\n    }\n\n    const [faceFrontAzimuth, faceFrontAltitude] = calcAzimuthAltitude(this.faceFront);\n    _eulerA.set(0.0, 0.5 * Math.PI + faceFrontAzimuth, faceFrontAltitude, 'YZX');\n\n    return target.setFromEuler(_eulerA).premultiply(_quatD.copy(this._restHeadWorldQuaternion).invert());\n  }\n\n  /**\n   * Get its LookAt direction in world coordinate.\n   *\n   * @param target A target `THREE.Vector3`\n   */\n  public getLookAtWorldDirection(target: THREE.Vector3): THREE.Vector3 {\n    this.getLookAtWorldQuaternion(_quatB);\n    this.getFaceFrontQuaternion(_quatC);\n\n    return target\n      .copy(VEC3_POSITIVE_Z)\n      .applyQuaternion(_quatB)\n      .applyQuaternion(_quatC)\n      .applyEuler(this.getEuler(_eulerA));\n  }\n\n  /**\n   * Set its lookAt target position.\n   *\n   * Note that its result will be instantly overwritten if {@link VRMLookAtHead.autoUpdate} is enabled.\n   *\n   * If you want to track an object continuously, you might want to use {@link target} instead.\n   *\n   * @param position A target position, in world space\n   */\n  public lookAt(position: THREE.Vector3): void {\n    // Look at direction in local coordinate\n    const headRotDiffInv = _quatA\n      .copy(this._restHeadWorldQuaternion)\n      .multiply(quatInvertCompat(this.getLookAtWorldQuaternion(_quatB)));\n    const headPos = this.getLookAtWorldPosition(_v3B);\n    const lookAtDir = _v3C.copy(position).sub(headPos).applyQuaternion(headRotDiffInv).normalize();\n\n    // calculate angles\n    const [azimuthFrom, altitudeFrom] = calcAzimuthAltitude(this.faceFront);\n    const [azimuthTo, altitudeTo] = calcAzimuthAltitude(lookAtDir);\n    const yaw = sanitizeAngle(azimuthTo - azimuthFrom);\n    const pitch = sanitizeAngle(altitudeFrom - altitudeTo); // spinning (1, 0, 0) CCW around Z axis makes the vector look up, while spinning (0, 0, 1) CCW around X axis makes the vector look down\n\n    // apply angles\n    this._yaw = THREE.MathUtils.RAD2DEG * yaw;\n    this._pitch = THREE.MathUtils.RAD2DEG * pitch;\n\n    this._needsUpdate = true;\n  }\n\n  /**\n   * Update the VRMLookAtHead.\n   * If {@link autoUpdate} is enabled, this will make it look at the {@link target}.\n   *\n   * @param delta deltaTime, it isn't used though. You can use the parameter if you want to use this in your own extended {@link VRMLookAt}.\n   */\n  public update(delta: number): void {\n    if (this.target != null && this.autoUpdate) {\n      this.lookAt(this.target.getWorldPosition(_v3A));\n    }\n\n    if (this._needsUpdate) {\n      this._needsUpdate = false;\n\n      this.applier.applyYawPitch(this._yaw, this._pitch);\n    }\n  }\n}\n", "import * as THREE from 'three';\n\nconst _position = new THREE.Vector3();\nconst _scale = new THREE.Vector3();\n\n/**\n * A replacement of `Object3D.getWorldQuaternion`.\n * Extract the world quaternion of an object from its world space matrix, without calling `Object3D.updateWorldMatrix`.\n * Use this when you're sure that the world matrix is up-to-date.\n *\n * @param object The object\n * @param out A target quaternion\n */\nexport function getWorldQuaternionLite(object: THREE.Object3D, out: THREE.Quaternion): THREE.Quaternion {\n  object.matrixWorld.decompose(_position, out, _scale);\n  return out;\n}\n", "import * as THREE from 'three';\n\n/**\n * Calculate azimuth / altitude angles from a vector.\n *\n * This returns a difference of angles from (1, 0, 0).\n * Azimuth represents an angle around Y axis.\n * Altitude represents an angle around Z axis.\n * It is rotated in intrinsic Y-Z order.\n *\n * @param vector The vector\n * @returns A tuple contains two angles, `[ azimuth, altitude ]`\n */\nexport function calcAzimuthAltitude(vector: THREE.Vector3): [azimuth: number, altitude: number] {\n  return [Math.atan2(-vector.z, vector.x), Math.atan2(vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z))];\n}\n", "/**\n * Make sure the angle is within -PI to PI.\n *\n * @example\n * ```js\n * sanitizeAngle(1.5 * Math.PI) // -0.5 * PI\n * ```\n *\n * @param angle An input angle\n */\nexport function sanitizeAngle(angle: number): number {\n  const roundTurn = Math.round(angle / 2.0 / Math.PI);\n  return angle - 2.0 * Math.PI * roundTurn;\n}\n", "import { VRMHumanoid } from '../humanoid';\nimport * as THREE from 'three';\nimport type { VRMLookAtApplier } from './VRMLookAtApplier';\nimport { VRMLookAtRangeMap } from './VRMLookAtRangeMap';\nimport { calcAzimuthAltitude } from './utils/calcAzimuthAltitude';\nimport { getWorldQuaternionLite } from '../utils/getWorldQuaternionLite';\n\nconst VEC3_POSITIVE_Z = new THREE.Vector3(0.0, 0.0, 1.0);\n\nconst _quatA = new THREE.Quaternion();\nconst _quatB = new THREE.Quaternion();\nconst _eulerA = new THREE.Euler(0.0, 0.0, 0.0, 'YXZ');\n\n/**\n * A class that applies eye gaze directions to a VRM.\n * It will be used by {@link VRMLookAt}.\n */\nexport class VRMLookAtBoneApplier implements VRMLookAtApplier {\n  /**\n   * Represent its type of applier.\n   */\n  public static readonly type = 'bone';\n\n  /**\n   * Its associated {@link VRMHumanoid}.\n   */\n  public readonly humanoid: VRMHumanoid;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for horizontal inward movement. The left eye moves right. The right eye moves left.\n   */\n  public rangeMapHorizontalInner: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for horizontal outward movement. The left eye moves left. The right eye moves right.\n   */\n  public rangeMapHorizontalOuter: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for vertical downward movement. Both eyes move upwards.\n   */\n  public rangeMapVerticalDown: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for vertical upward movement. Both eyes move downwards.\n   */\n  public rangeMapVerticalUp: VRMLookAtRangeMap;\n\n  /**\n   * The front direction of the face.\n   * Intended to be used for VRM 0.0 compat (VRM 0.0 models are facing Z- instead of Z+).\n   * You usually don't want to touch this.\n   */\n  public faceFront: THREE.Vector3;\n\n  /**\n   * The rest quaternion of LeftEye bone.\n   */\n  private _restQuatLeftEye: THREE.Quaternion;\n\n  /**\n   * The rest quaternion of RightEye bone.\n   */\n  private _restQuatRightEye: THREE.Quaternion;\n\n  /**\n   * The world-space rest quaternion of the parent of the humanoid LeftEye.\n   */\n  private _restLeftEyeParentWorldQuat: THREE.Quaternion;\n\n  /**\n   * The world-space rest quaternion of the parent of the humanoid RightEye.\n   */\n  private _restRightEyeParentWorldQuat: THREE.Quaternion;\n\n  /**\n   * Create a new {@link VRMLookAtBoneApplier}.\n   *\n   * @param humanoid A {@link VRMHumanoid}\n   * @param rangeMapHorizontalInner A {@link VRMLookAtRangeMap} used for inner transverse direction\n   * @param rangeMapHorizontalOuter A {@link VRMLookAtRangeMap} used for outer transverse direction\n   * @param rangeMapVerticalDown A {@link VRMLookAtRangeMap} used for down direction\n   * @param rangeMapVerticalUp A {@link VRMLookAtRangeMap} used for up direction\n   */\n  public constructor(\n    humanoid: VRMHumanoid,\n    rangeMapHorizontalInner: VRMLookAtRangeMap,\n    rangeMapHorizontalOuter: VRMLookAtRangeMap,\n    rangeMapVerticalDown: VRMLookAtRangeMap,\n    rangeMapVerticalUp: VRMLookAtRangeMap,\n  ) {\n    this.humanoid = humanoid;\n\n    this.rangeMapHorizontalInner = rangeMapHorizontalInner;\n    this.rangeMapHorizontalOuter = rangeMapHorizontalOuter;\n    this.rangeMapVerticalDown = rangeMapVerticalDown;\n    this.rangeMapVerticalUp = rangeMapVerticalUp;\n\n    this.faceFront = new THREE.Vector3(0.0, 0.0, 1.0);\n\n    // set rest quaternions\n    this._restQuatLeftEye = new THREE.Quaternion();\n    this._restQuatRightEye = new THREE.Quaternion();\n    this._restLeftEyeParentWorldQuat = new THREE.Quaternion();\n    this._restRightEyeParentWorldQuat = new THREE.Quaternion();\n\n    const leftEye = this.humanoid.getRawBoneNode('leftEye');\n    const rightEye = this.humanoid.getRawBoneNode('rightEye');\n\n    if (leftEye) {\n      this._restQuatLeftEye.copy(leftEye.quaternion);\n      getWorldQuaternionLite(leftEye.parent!, this._restLeftEyeParentWorldQuat);\n    }\n\n    if (rightEye) {\n      this._restQuatRightEye.copy(rightEye.quaternion);\n      getWorldQuaternionLite(rightEye.parent!, this._restRightEyeParentWorldQuat);\n    }\n  }\n\n  /**\n   * Apply the input angle to its associated VRM model.\n   *\n   * @param yaw Rotation around Y axis, in degree\n   * @param pitch Rotation around X axis, in degree\n   */\n  public applyYawPitch(yaw: number, pitch: number): void {\n    const leftEye = this.humanoid.getRawBoneNode('leftEye');\n    const rightEye = this.humanoid.getRawBoneNode('rightEye');\n    const leftEyeNormalized = this.humanoid.getNormalizedBoneNode('leftEye');\n    const rightEyeNormalized = this.humanoid.getNormalizedBoneNode('rightEye');\n    // left\n    if (leftEye) {\n      if (pitch < 0.0) {\n        _eulerA.x = -THREE.MathUtils.DEG2RAD * this.rangeMapVerticalDown.map(-pitch);\n      } else {\n        _eulerA.x = THREE.MathUtils.DEG2RAD * this.rangeMapVerticalUp.map(pitch);\n      }\n\n      if (yaw < 0.0) {\n        _eulerA.y = -THREE.MathUtils.DEG2RAD * this.rangeMapHorizontalInner.map(-yaw);\n      } else {\n        _eulerA.y = THREE.MathUtils.DEG2RAD * this.rangeMapHorizontalOuter.map(yaw);\n      }\n\n      _quatA.setFromEuler(_eulerA);\n      this._getWorldFaceFrontQuat(_quatB);\n\n      // _quatB * _quatA * _quatB^-1\n      // where _quatA is LookAt rotation\n      // and _quatB is worldFaceFrontQuat\n      leftEyeNormalized!.quaternion.copy(_quatB).multiply(_quatA).multiply(_quatB.invert());\n\n      _quatA.copy(this._restLeftEyeParentWorldQuat);\n\n      // _quatA^-1 * leftEyeNormalized.quaternion * _quatA * restQuatLeftEye\n      // where _quatA is restLeftEyeParentWorldQuat\n      leftEye.quaternion\n        .copy(leftEyeNormalized!.quaternion)\n        .multiply(_quatA)\n        .premultiply(_quatA.invert())\n        .multiply(this._restQuatLeftEye);\n    }\n\n    // right\n    if (rightEye) {\n      if (pitch < 0.0) {\n        _eulerA.x = -THREE.MathUtils.DEG2RAD * this.rangeMapVerticalDown.map(-pitch);\n      } else {\n        _eulerA.x = THREE.MathUtils.DEG2RAD * this.rangeMapVerticalUp.map(pitch);\n      }\n\n      if (yaw < 0.0) {\n        _eulerA.y = -THREE.MathUtils.DEG2RAD * this.rangeMapHorizontalOuter.map(-yaw);\n      } else {\n        _eulerA.y = THREE.MathUtils.DEG2RAD * this.rangeMapHorizontalInner.map(yaw);\n      }\n\n      _quatA.setFromEuler(_eulerA);\n      this._getWorldFaceFrontQuat(_quatB);\n\n      // _quatB * _quatA * _quatB^-1\n      // where _quatA is LookAt rotation\n      // and _quatB is worldFaceFrontQuat\n      rightEyeNormalized!.quaternion.copy(_quatB).multiply(_quatA).multiply(_quatB.invert());\n\n      _quatA.copy(this._restRightEyeParentWorldQuat);\n\n      // _quatA^-1 * rightEyeNormalized.quaternion * _quatA * restQuatRightEye\n      // where _quatA is restRightEyeParentWorldQuat\n      rightEye.quaternion\n        .copy(rightEyeNormalized!.quaternion)\n        .multiply(_quatA)\n        .premultiply(_quatA.invert())\n        .multiply(this._restQuatRightEye);\n    }\n  }\n\n  /**\n   * @deprecated Use {@link applyYawPitch} instead.\n   */\n  public lookAt(euler: THREE.Euler): void {\n    console.warn('VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.');\n\n    const yaw = THREE.MathUtils.RAD2DEG * euler.y;\n    const pitch = THREE.MathUtils.RAD2DEG * euler.x;\n\n    this.applyYawPitch(yaw, pitch);\n  }\n\n  /**\n   * Get a quaternion that rotates the world-space +Z unit vector to the {@link faceFront} direction.\n   *\n   * @param target A target `THREE.Quaternion`\n   */\n  private _getWorldFaceFrontQuat(target: THREE.Quaternion): THREE.Quaternion {\n    if (this.faceFront.distanceToSquared(VEC3_POSITIVE_Z) < 0.01) {\n      return target.identity();\n    }\n\n    const [faceFrontAzimuth, faceFrontAltitude] = calcAzimuthAltitude(this.faceFront);\n    _eulerA.set(0.0, 0.5 * Math.PI + faceFrontAzimuth, faceFrontAltitude, 'YZX');\n\n    return target.setFromEuler(_eulerA);\n  }\n}\n", "import { VRMExpressionManager } from '../expressions';\nimport * as THREE from 'three';\nimport type { VRMLookAtApplier } from './VRMLookAtApplier';\nimport { VRMLookAtRangeMap } from './VRMLookAtRangeMap';\n\n/**\n * A class that applies eye gaze directions to a VRM.\n * It will be used by {@link VRMLookAt}.\n */\nexport class VRMLookAtExpressionApplier implements VRMLookAtApplier {\n  /**\n   * Represent its type of applier.\n   */\n  public static readonly type = 'expression';\n\n  /**\n   * Its associated {@link VRMExpressionManager}.\n   */\n  public readonly expressions: VRMExpressionManager;\n\n  /**\n   * It won't be used in expression applier.\n   * See also: {@link rangeMapHorizontalOuter}\n   */\n  public rangeMapHorizontalInner: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for horizontal movement. Both eyes move left or right.\n   */\n  public rangeMapHorizontalOuter: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for vertical downward movement. Both eyes move upwards.\n   */\n  public rangeMapVerticalDown: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for vertical upward movement. Both eyes move downwards.\n   */\n  public rangeMapVerticalUp: VRMLookAtRangeMap;\n\n  /**\n   * Create a new {@link VRMLookAtExpressionApplier}.\n   *\n   * @param expressions A {@link VRMExpressionManager}\n   * @param rangeMapHorizontalInner A {@link VRMLookAtRangeMap} used for inner transverse direction\n   * @param rangeMapHorizontalOuter A {@link VRMLookAtRangeMap} used for outer transverse direction\n   * @param rangeMapVerticalDown A {@link VRMLookAtRangeMap} used for down direction\n   * @param rangeMapVerticalUp A {@link VRMLookAtRangeMap} used for up direction\n   */\n  public constructor(\n    expressions: VRMExpressionManager,\n    rangeMapHorizontalInner: VRMLookAtRangeMap,\n    rangeMapHorizontalOuter: VRMLookAtRangeMap,\n    rangeMapVerticalDown: VRMLookAtRangeMap,\n    rangeMapVerticalUp: VRMLookAtRangeMap,\n  ) {\n    this.expressions = expressions;\n\n    this.rangeMapHorizontalInner = rangeMapHorizontalInner;\n    this.rangeMapHorizontalOuter = rangeMapHorizontalOuter;\n    this.rangeMapVerticalDown = rangeMapVerticalDown;\n    this.rangeMapVerticalUp = rangeMapVerticalUp;\n  }\n\n  /**\n   * Apply the input angle to its associated VRM model.\n   *\n   * @param yaw Rotation around Y axis, in degree\n   * @param pitch Rotation around X axis, in degree\n   */\n  public applyYawPitch(yaw: number, pitch: number): void {\n    if (pitch < 0.0) {\n      this.expressions.setValue('lookDown', 0.0);\n      this.expressions.setValue('lookUp', this.rangeMapVerticalUp.map(-pitch));\n    } else {\n      this.expressions.setValue('lookUp', 0.0);\n      this.expressions.setValue('lookDown', this.rangeMapVerticalDown.map(pitch));\n    }\n\n    if (yaw < 0.0) {\n      this.expressions.setValue('lookLeft', 0.0);\n      this.expressions.setValue('lookRight', this.rangeMapHorizontalOuter.map(-yaw));\n    } else {\n      this.expressions.setValue('lookRight', 0.0);\n      this.expressions.setValue('lookLeft', this.rangeMapHorizontalOuter.map(yaw));\n    }\n  }\n\n  /**\n   * @deprecated Use {@link applyYawPitch} instead.\n   */\n  public lookAt(euler: THREE.Euler): void {\n    console.warn('VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.');\n\n    const yaw = THREE.MathUtils.RAD2DEG * euler.y;\n    const pitch = THREE.MathUtils.RAD2DEG * euler.x;\n\n    this.applyYawPitch(yaw, pitch);\n  }\n}\n", "import { saturate } from '../utils/saturate';\n\nexport class VRMLookAtRangeMap {\n  /**\n   * Limits the maximum angle of the input angle of the LookAt vector from the front of the head (the positive z axis).\n   */\n  public inputMaxValue: number;\n\n  /**\n   * Represents an angle (in degrees) for bone type of LookAt appliers, or a weight for expression type of LookAt appliers.\n   * The input value will take `1.0` when the input angle equals (or greater) to {@link inputMaxValue}.\n   */\n  public outputScale: number;\n\n  /**\n   * Create a new {@link VRMLookAtRangeMap}.\n   *\n   * @param inputMaxValue The {@link inputMaxValue} of the map\n   * @param outputScale The {@link outputScale} of the map\n   */\n  public constructor(inputMaxValue: number, outputScale: number) {\n    this.inputMaxValue = inputMaxValue;\n    this.outputScale = outputScale;\n  }\n\n  /**\n   * Evaluate an input value and output a mapped value.\n   * @param src The input value\n   */\n  public map(src: number): number {\n    return this.outputScale * saturate(src / this.inputMaxValue);\n  }\n}\n", "import type * as THREE from 'three';\nimport type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport type { VRMExpressionManager } from '../expressions/VRMExpressionManager';\nimport type { VRMHumanoid } from '../humanoid/VRMHumanoid';\nimport { VRMLookAtHelper } from './helpers/VRMLookAtHelper';\nimport { VRMLookAt } from './VRMLookAt';\nimport type { VRMLookAtApplier } from './VRMLookAtApplier';\nimport { VRMLookAtBoneApplier } from './VRMLookAtBoneApplier';\nimport { VRMLookAtExpressionApplier } from './VRMLookAtExpressionApplier';\nimport type { VRMLookAtLoaderPluginOptions } from './VRMLookAtLoaderPluginOptions';\nimport { VRMLookAtRangeMap } from './VRMLookAtRangeMap';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * The minimum permitted value for {@link V1VRMSchema.LookAtRangeMap.inputMaxValue}.\n * If the given value is smaller than this, the loader shows a warning and clamps up the value.\n */\nconst INPUT_MAX_VALUE_MINIMUM = 0.01;\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRMLookAt} from a VRM extension of a GLTF.\n */\nexport class VRMLookAtLoaderPlugin implements GLTFLoaderPlugin {\n  /**\n   * Specify an Object3D to add {@link VRMLookAtHelper} s.\n   * If not specified, helper will not be created.\n   * If `renderOrder` is set to the root, helpers will copy the same `renderOrder` .\n   */\n  public helperRoot?: THREE.Object3D;\n\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMLookAtLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser, options?: VRMLookAtLoaderPluginOptions) {\n    this.parser = parser;\n\n    this.helperRoot = options?.helperRoot;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    const vrmHumanoid = gltf.userData.vrmHumanoid as VRMHumanoid | undefined;\n\n    // explicitly distinguish null and undefined\n    // since vrmHumanoid might be null as a result\n    if (vrmHumanoid === null) {\n      return;\n    } else if (vrmHumanoid === undefined) {\n      throw new Error('VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first');\n    }\n\n    const vrmExpressionManager = gltf.userData.vrmExpressionManager as VRMExpressionManager | undefined;\n\n    if (vrmExpressionManager === null) {\n      return;\n    } else if (vrmExpressionManager === undefined) {\n      throw new Error(\n        'VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first',\n      );\n    }\n\n    gltf.userData.vrmLookAt = await this._import(gltf, vrmHumanoid, vrmExpressionManager);\n  }\n\n  /**\n   * Import a {@link VRMLookAt} from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   * @param humanoid A {@link VRMHumanoid} instance that represents the VRM\n   * @param expressions A {@link VRMExpressionManager} instance that represents the VRM\n   */\n  private async _import(\n    gltf: GLTF,\n    humanoid: VRMHumanoid | null,\n    expressions: VRMExpressionManager | null,\n  ): Promise<VRMLookAt | null> {\n    if (humanoid == null || expressions == null) {\n      return null;\n    }\n\n    const v1Result = await this._v1Import(gltf, humanoid, expressions);\n    if (v1Result) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf, humanoid, expressions);\n    if (v0Result) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(\n    gltf: GLTF,\n    humanoid: VRMHumanoid,\n    expressions: VRMExpressionManager,\n  ): Promise<VRMLookAt | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (!extension) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaLookAt = extension.lookAt;\n    if (!schemaLookAt) {\n      return null;\n    }\n\n    const defaultOutputScale = schemaLookAt.type === 'expression' ? 1.0 : 10.0;\n\n    const mapHI = this._v1ImportRangeMap(schemaLookAt.rangeMapHorizontalInner, defaultOutputScale);\n    const mapHO = this._v1ImportRangeMap(schemaLookAt.rangeMapHorizontalOuter, defaultOutputScale);\n    const mapVD = this._v1ImportRangeMap(schemaLookAt.rangeMapVerticalDown, defaultOutputScale);\n    const mapVU = this._v1ImportRangeMap(schemaLookAt.rangeMapVerticalUp, defaultOutputScale);\n\n    let applier;\n\n    if (schemaLookAt.type === 'expression') {\n      applier = new VRMLookAtExpressionApplier(expressions, mapHI, mapHO, mapVD, mapVU);\n    } else {\n      applier = new VRMLookAtBoneApplier(humanoid, mapHI, mapHO, mapVD, mapVU);\n    }\n\n    const lookAt = this._importLookAt(humanoid, applier);\n\n    lookAt.offsetFromHeadBone.fromArray(schemaLookAt.offsetFromHeadBone ?? [0.0, 0.06, 0.0]);\n\n    return lookAt;\n  }\n\n  private _v1ImportRangeMap(\n    schemaRangeMap: V1VRMSchema.LookAtRangeMap | undefined,\n    defaultOutputScale: number,\n  ): VRMLookAtRangeMap {\n    let inputMaxValue = schemaRangeMap?.inputMaxValue ?? 90.0;\n    const outputScale = schemaRangeMap?.outputScale ?? defaultOutputScale;\n\n    // It might cause NaN when `inputMaxValue` is too small\n    // which makes the mesh of the head disappear\n    // See: https://github.com/pixiv/three-vrm/issues/1201\n    if (inputMaxValue < INPUT_MAX_VALUE_MINIMUM) {\n      console.warn(\n        'VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!',\n      );\n      inputMaxValue = INPUT_MAX_VALUE_MINIMUM;\n    }\n\n    return new VRMLookAtRangeMap(inputMaxValue, outputScale);\n  }\n\n  private async _v0Import(\n    gltf: GLTF,\n    humanoid: VRMHumanoid,\n    expressions: VRMExpressionManager,\n  ): Promise<VRMLookAt | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const defaultOutputScale = schemaFirstPerson.lookAtTypeName === 'BlendShape' ? 1.0 : 10.0;\n\n    const mapHI = this._v0ImportDegreeMap(schemaFirstPerson.lookAtHorizontalInner, defaultOutputScale);\n    const mapHO = this._v0ImportDegreeMap(schemaFirstPerson.lookAtHorizontalOuter, defaultOutputScale);\n    const mapVD = this._v0ImportDegreeMap(schemaFirstPerson.lookAtVerticalDown, defaultOutputScale);\n    const mapVU = this._v0ImportDegreeMap(schemaFirstPerson.lookAtVerticalUp, defaultOutputScale);\n\n    let applier;\n\n    if (schemaFirstPerson.lookAtTypeName === 'BlendShape') {\n      applier = new VRMLookAtExpressionApplier(expressions, mapHI, mapHO, mapVD, mapVU);\n    } else {\n      applier = new VRMLookAtBoneApplier(humanoid, mapHI, mapHO, mapVD, mapVU);\n    }\n\n    const lookAt = this._importLookAt(humanoid, applier);\n\n    if (schemaFirstPerson.firstPersonBoneOffset) {\n      lookAt.offsetFromHeadBone.set(\n        schemaFirstPerson.firstPersonBoneOffset.x ?? 0.0,\n        schemaFirstPerson.firstPersonBoneOffset.y ?? 0.06,\n        -(schemaFirstPerson.firstPersonBoneOffset.z ?? 0.0),\n      );\n    } else {\n      lookAt.offsetFromHeadBone.set(0.0, 0.06, 0.0);\n    }\n\n    // VRM 0.0 are facing Z- instead of Z+\n    lookAt.faceFront.set(0.0, 0.0, -1.0);\n\n    if (applier instanceof VRMLookAtBoneApplier) {\n      applier.faceFront.set(0.0, 0.0, -1.0);\n    }\n\n    return lookAt;\n  }\n\n  private _v0ImportDegreeMap(\n    schemaDegreeMap: V0VRM.FirstPersonDegreeMap | undefined,\n    defaultOutputScale: number,\n  ): VRMLookAtRangeMap {\n    const curve = schemaDegreeMap?.curve;\n    if (JSON.stringify(curve) !== '[0,0,0,1,1,1,1,0]') {\n      console.warn('Curves of LookAtDegreeMap defined in VRM 0.0 are not supported');\n    }\n\n    let xRange = schemaDegreeMap?.xRange ?? 90.0;\n    const yRange = schemaDegreeMap?.yRange ?? defaultOutputScale;\n\n    // It might cause NaN when `xRange` is too small\n    // which makes the mesh of the head disappear\n    // See: https://github.com/pixiv/three-vrm/issues/1201\n    if (xRange < INPUT_MAX_VALUE_MINIMUM) {\n      console.warn('VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!');\n      xRange = INPUT_MAX_VALUE_MINIMUM;\n    }\n\n    return new VRMLookAtRangeMap(xRange, yRange);\n  }\n\n  private _importLookAt(humanoid: VRMHumanoid, applier: VRMLookAtApplier): VRMLookAt {\n    const lookAt = new VRMLookAt(humanoid, applier);\n\n    if (this.helperRoot) {\n      const helper = new VRMLookAtHelper(lookAt);\n      this.helperRoot.add(helper);\n      helper.renderOrder = this.helperRoot.renderOrder;\n    }\n\n    return lookAt;\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * Represents a type of applier.\n */\nexport const VRMLookAtTypeName = {\n  Bone: 'bone',\n  Expression: 'expression',\n};\n\nexport type VRMLookAtTypeName = (typeof VRMLookAtTypeName)[keyof typeof VRMLookAtTypeName];\n", "import type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport type { VRM0Meta } from './VRM0Meta';\nimport type { VRM1Meta } from './VRM1Meta';\nimport type { VRMMeta } from './VRMMeta';\nimport type { VRMMetaLoaderPluginOptions } from './VRMMetaLoaderPluginOptions';\nimport type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport * as THREE from 'three';\nimport { resolveURL } from '../utils/resolveURL';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRM1Meta} from a VRM extension of a GLTF.\n */\nexport class VRMMetaLoaderPlugin implements GLTFLoaderPlugin {\n  public readonly parser: GLTFParser;\n\n  /**\n   * If `false`, it won't load its thumbnail image ({@link VRM1Meta.thumbnailImage}).\n   * `false` by default.\n   */\n  public needThumbnailImage: boolean;\n\n  /**\n   * A list of license urls.\n   * This meta loader will accept these `licenseUrl`s.\n   * Otherwise it won't be loaded.\n   */\n  public acceptLicenseUrls: string[];\n\n  /**\n   * Whether it should accept VRM0.0 meta or not.\n   * Note that it might load {@link VRM0Meta} instead of {@link VRM1Meta} when this is `true`.\n   * `true` by default.\n   */\n  public acceptV0Meta: boolean;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMMetaLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser, options?: VRMMetaLoaderPluginOptions) {\n    this.parser = parser;\n\n    this.needThumbnailImage = options?.needThumbnailImage ?? false;\n    this.acceptLicenseUrls = options?.acceptLicenseUrls ?? ['https://vrm.dev/licenses/1.0/'];\n    this.acceptV0Meta = options?.acceptV0Meta ?? true;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    gltf.userData.vrmMeta = await this._import(gltf);\n  }\n\n  private async _import(gltf: GLTF): Promise<VRMMeta | null> {\n    const v1Result = await this._v1Import(gltf);\n    if (v1Result != null) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf);\n    if (v0Result != null) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(gltf: GLTF): Promise<VRM1Meta | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (extension == null) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaMeta = extension.meta;\n    if (!schemaMeta) {\n      return null;\n    }\n\n    // throw an error if acceptV0Meta is false\n    const licenseUrl = schemaMeta.licenseUrl;\n    const acceptLicenseUrlsSet = new Set(this.acceptLicenseUrls);\n    if (!acceptLicenseUrlsSet.has(licenseUrl)) {\n      throw new Error(`VRMMetaLoaderPlugin: The license url \"${licenseUrl}\" is not accepted`);\n    }\n\n    let thumbnailImage: HTMLImageElement | undefined = undefined;\n    if (this.needThumbnailImage && schemaMeta.thumbnailImage != null) {\n      thumbnailImage = (await this._extractGLTFImage(schemaMeta.thumbnailImage)) ?? undefined;\n    }\n\n    return {\n      metaVersion: '1',\n      name: schemaMeta.name,\n      version: schemaMeta.version,\n      authors: schemaMeta.authors,\n      copyrightInformation: schemaMeta.copyrightInformation,\n      contactInformation: schemaMeta.contactInformation,\n      references: schemaMeta.references,\n      thirdPartyLicenses: schemaMeta.thirdPartyLicenses,\n      thumbnailImage,\n      licenseUrl: schemaMeta.licenseUrl,\n      avatarPermission: schemaMeta.avatarPermission,\n      allowExcessivelyViolentUsage: schemaMeta.allowExcessivelyViolentUsage,\n      allowExcessivelySexualUsage: schemaMeta.allowExcessivelySexualUsage,\n      commercialUsage: schemaMeta.commercialUsage,\n      allowPoliticalOrReligiousUsage: schemaMeta.allowPoliticalOrReligiousUsage,\n      allowAntisocialOrHateUsage: schemaMeta.allowAntisocialOrHateUsage,\n      creditNotation: schemaMeta.creditNotation,\n      allowRedistribution: schemaMeta.allowRedistribution,\n      modification: schemaMeta.modification,\n      otherLicenseUrl: schemaMeta.otherLicenseUrl,\n    };\n  }\n\n  private async _v0Import(gltf: GLTF): Promise<VRM0Meta | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaMeta = vrmExt.meta;\n    if (!schemaMeta) {\n      return null;\n    }\n\n    // throw an error if acceptV0Meta is false\n    if (!this.acceptV0Meta) {\n      throw new Error('VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false');\n    }\n\n    // load thumbnail texture\n    let texture: THREE.Texture | null | undefined;\n    if (this.needThumbnailImage && schemaMeta.texture != null && schemaMeta.texture !== -1) {\n      texture = await this.parser.getDependency('texture', schemaMeta.texture);\n    }\n\n    return {\n      metaVersion: '0',\n      allowedUserName: schemaMeta.allowedUserName,\n      author: schemaMeta.author,\n      commercialUssageName: schemaMeta.commercialUssageName,\n      contactInformation: schemaMeta.contactInformation,\n      licenseName: schemaMeta.licenseName,\n      otherLicenseUrl: schemaMeta.otherLicenseUrl,\n      otherPermissionUrl: schemaMeta.otherPermissionUrl,\n      reference: schemaMeta.reference,\n      sexualUssageName: schemaMeta.sexualUssageName,\n      texture: texture ?? undefined,\n      title: schemaMeta.title,\n      version: schemaMeta.version,\n      violentUssageName: schemaMeta.violentUssageName,\n    };\n  }\n\n  private async _extractGLTFImage(index: number): Promise<HTMLImageElement | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    const source = json.images?.[index];\n\n    if (source == null) {\n      console.warn(\n        `VRMMetaLoaderPlugin: Attempt to use images[${index}] of glTF as a thumbnail but the image doesn't exist`,\n      );\n      return null;\n    }\n\n    // Ref: https://github.com/mrdoob/three.js/blob/r124/examples/jsm/loaders/GLTFLoader.js#L2467\n\n    // `source.uri` might be a reference to a file\n    let sourceURI: string | undefined = source.uri;\n\n    // Load the binary as a blob\n    if (source.bufferView != null) {\n      const bufferView = await this.parser.getDependency('bufferView', source.bufferView);\n      const blob = new Blob([bufferView], { type: source.mimeType });\n      sourceURI = URL.createObjectURL(blob);\n    }\n\n    if (sourceURI == null) {\n      console.warn(\n        `VRMMetaLoaderPlugin: Attempt to use images[${index}] of glTF as a thumbnail but the image couldn't load properly`,\n      );\n      return null;\n    }\n\n    const loader = new THREE.ImageLoader();\n    return await loader.loadAsync(resolveURL(sourceURI, (this.parser as any).options.path)).catch((error) => {\n      console.error(error);\n      console.warn('VRMMetaLoaderPlugin: Failed to load a thumbnail image');\n      return null;\n    });\n  }\n}\n", "/**\n * Yoinked from https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/GLTFLoader.js\n */\nexport function resolveURL(url: string, path: string): string {\n  // Invalid URL\n  if (typeof url !== 'string' || url === '') return '';\n\n  // Host Relative URL\n  if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n    path = path.replace(/(^https?:\\/\\/[^/]+).*/i, '$1');\n  }\n\n  // Absolute URL http://,https://,//\n  if (/^(https?:)?\\/\\//i.test(url)) return url;\n\n  // Data URI\n  if (/^data:.*,.*$/i.test(url)) return url;\n\n  // Blob URL\n  if (/^blob:.*$/i.test(url)) return url;\n\n  // Relative URL\n  return path + url;\n}\n", "import * as THREE from 'three';\nimport { VRMExpressionManager } from './expressions/VRMExpressionManager';\nimport { VRMFirstPerson } from './firstPerson/VRMFirstPerson';\nimport { VRMHumanoid } from './humanoid/VRMHumanoid';\nimport { VRMLookAt } from './lookAt/VRMLookAt';\nimport { VRMMeta } from './meta/VRMMeta';\nimport { VRMCoreParameters } from './VRMCoreParameters';\n\n/**\n * A class that represents a single VRM model.\n * This class only includes core spec of the VRM (`VRMC_vrm`).\n */\nexport class VRMCore {\n  /**\n   * `THREE.Group` that contains the entire VRM.\n   */\n  public readonly scene: THREE.Group;\n\n  /**\n   * Contains meta fields of the VRM.\n   * You might want to refer these license fields before use your VRMs.\n   */\n  public readonly meta: VRMMeta;\n\n  /**\n   * Contains {@link VRMHumanoid} of the VRM.\n   * You can control each bones using {@link VRMHumanoid.getNormalizedBoneNode} or {@link VRMHumanoid.getRawBoneNode}.\n   *\n   * @TODO Add a link to VRM spec\n   */\n  public readonly humanoid: VRMHumanoid;\n\n  /**\n   * Contains {@link VRMExpressionManager} of the VRM.\n   * You might want to control these facial expressions via {@link VRMExpressionManager.setValue}.\n   */\n  public readonly expressionManager?: VRMExpressionManager;\n\n  /**\n   * Contains {@link VRMFirstPerson} of the VRM.\n   * VRMFirstPerson is mostly used for mesh culling for first person view.\n   */\n  public readonly firstPerson?: VRMFirstPerson;\n\n  /**\n   * Contains {@link VRMLookAt} of the VRM.\n   * You might want to use {@link VRMLookAt.target} to control the eye direction of your VRMs.\n   */\n  public readonly lookAt?: VRMLookAt;\n\n  /**\n   * Create a new VRM instance.\n   *\n   * @param params {@link VRMParameters} that represents components of the VRM\n   */\n  public constructor(params: VRMCoreParameters) {\n    this.scene = params.scene;\n    this.meta = params.meta;\n    this.humanoid = params.humanoid;\n    this.expressionManager = params.expressionManager;\n    this.firstPerson = params.firstPerson;\n    this.lookAt = params.lookAt;\n  }\n\n  /**\n   * **You need to call this on your update loop.**\n   *\n   * This function updates every VRM components.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    this.humanoid.update();\n\n    if (this.lookAt) {\n      this.lookAt.update(delta);\n    }\n\n    if (this.expressionManager) {\n      this.expressionManager.update();\n    }\n  }\n}\n", "import { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { VRMCoreLoaderPluginOptions } from './VRMCoreLoaderPluginOptions';\nimport { VRMCore } from './VRMCore';\nimport { VRMExpressionLoaderPlugin } from './expressions/VRMExpressionLoaderPlugin';\nimport { VRMFirstPersonLoaderPlugin } from './firstPerson/VRMFirstPersonLoaderPlugin';\nimport { VRMHumanoidLoaderPlugin } from './humanoid/VRMHumanoidLoaderPlugin';\nimport { VRMMetaLoaderPlugin } from './meta/VRMMetaLoaderPlugin';\nimport { VRMLookAtLoaderPlugin } from './lookAt/VRMLookAtLoaderPlugin';\nimport type { VRMHumanoid } from './humanoid';\nimport type { VRMMeta } from './meta';\n\nexport class VRMCoreLoaderPlugin implements GLTFLoaderPlugin {\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMC_vrm';\n  }\n\n  public readonly parser: GLTFParser;\n\n  public readonly expressionPlugin: VRMExpressionLoaderPlugin;\n  public readonly firstPersonPlugin: VRMFirstPersonLoaderPlugin;\n  public readonly humanoidPlugin: VRMHumanoidLoaderPlugin;\n  public readonly lookAtPlugin: VRMLookAtLoaderPlugin;\n  public readonly metaPlugin: VRMMetaLoaderPlugin;\n\n  public constructor(parser: GLTFParser, options?: VRMCoreLoaderPluginOptions) {\n    this.parser = parser;\n\n    const helperRoot = options?.helperRoot;\n    const autoUpdateHumanBones = options?.autoUpdateHumanBones;\n\n    this.expressionPlugin = options?.expressionPlugin ?? new VRMExpressionLoaderPlugin(parser);\n    this.firstPersonPlugin = options?.firstPersonPlugin ?? new VRMFirstPersonLoaderPlugin(parser);\n    this.humanoidPlugin =\n      options?.humanoidPlugin ?? new VRMHumanoidLoaderPlugin(parser, { helperRoot, autoUpdateHumanBones });\n    this.lookAtPlugin = options?.lookAtPlugin ?? new VRMLookAtLoaderPlugin(parser, { helperRoot });\n    this.metaPlugin = options?.metaPlugin ?? new VRMMetaLoaderPlugin(parser);\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    await this.metaPlugin.afterRoot(gltf);\n    await this.humanoidPlugin.afterRoot(gltf);\n    await this.expressionPlugin.afterRoot(gltf);\n    await this.lookAtPlugin.afterRoot(gltf);\n    await this.firstPersonPlugin.afterRoot(gltf);\n\n    const meta = gltf.userData.vrmMeta as VRMMeta | null;\n    const humanoid = gltf.userData.vrmHumanoid as VRMHumanoid | null;\n\n    // meta and humanoid are required to be a VRM.\n    // Don't create VRM if they are null\n    if (meta && humanoid) {\n      const vrmCore = new VRMCore({\n        scene: gltf.scene,\n        expressionManager: gltf.userData.vrmExpressionManager,\n        firstPerson: gltf.userData.vrmFirstPerson,\n        humanoid,\n        lookAt: gltf.userData.vrmLookAt,\n        meta,\n      });\n\n      gltf.userData.vrmCore = vrmCore;\n    }\n  }\n}\n", "import { VRMLookAt } from '@pixiv/three-vrm-core';\nimport * as THREE from 'three';\n\nconst RAD2DEG = 180 / Math.PI;\n\nconst _eulerA = /*@__PURE__*/ new THREE.Euler();\n\nexport class VRMLookAtQuaternionProxy extends THREE.Object3D {\n  public readonly vrmLookAt: VRMLookAt;\n  public override readonly type: string | 'VRMLookAtQuaternionProxy';\n\n  public constructor(lookAt: VRMLookAt) {\n    super();\n\n    this.vrmLookAt = lookAt;\n\n    this.type = 'VRMLookAtQuaternionProxy';\n\n    // See: https://github.com/mrdoob/three.js/blob/r158/src/core/Object3D.js#L65\n    const prevRotationOnChangeCallback = this.rotation._onChangeCallback;\n    this.rotation._onChange(() => {\n      prevRotationOnChangeCallback();\n      this._applyToLookAt();\n    });\n\n    const prevQuaternionOnChangeCallback = this.quaternion._onChangeCallback;\n    this.quaternion._onChange(() => {\n      prevQuaternionOnChangeCallback();\n      this._applyToLookAt();\n    });\n  }\n\n  private _applyToLookAt(): void {\n    _eulerA.setFromQuaternion(this.quaternion, VRMLookAt.EULER_ORDER);\n\n    this.vrmLookAt.yaw = RAD2DEG * _eulerA.y;\n    this.vrmLookAt.pitch = RAD2DEG * _eulerA.x;\n  }\n}\n", "import * as THREE from 'three';\nimport type { VRMExpressionPresetName, VRMHumanBoneName } from '@pixiv/three-vrm-core';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { createVRMAnimationClip } from './createVRMAnimationClip';\n\n/**\n * Represents a single VRM Animation.\n * You probably want to create an AnimationClip using {@link createVRMAnimationClip}.\n */\nexport class VRMAnimation {\n  public duration: number;\n  public restHipsPosition: THREE.Vector3;\n\n  public humanoidTracks: {\n    translation: Map<'hips', THREE.VectorKeyframeTrack>;\n    rotation: Map<VRMHumanBoneName, THREE.QuaternionKeyframeTrack>;\n  };\n  public expressionTracks: {\n    preset: Map<VRMExpressionPresetName, THREE.NumberKeyframeTrack>;\n    custom: Map<string, THREE.NumberKeyframeTrack>;\n  };\n  public lookAtTrack: THREE.QuaternionKeyframeTrack | null;\n\n  public constructor() {\n    this.duration = 0.0;\n    this.restHipsPosition = new THREE.Vector3();\n\n    this.humanoidTracks = {\n      translation: new Map(),\n      rotation: new Map(),\n    };\n\n    this.expressionTracks = {\n      preset: new Map(),\n      custom: new Map(),\n    };\n\n    this.lookAtTrack = null;\n  }\n}\n", "import * as THREE from 'three';\nimport { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\nimport { VRMCVRMAnimation } from '@pixiv/types-vrmc-vrm-animation-1.0';\nimport type { VRMHumanBoneName } from '@pixiv/three-vrm-core';\nimport { VRMExpressionPresetName, VRMHumanBoneParentMap } from '@pixiv/three-vrm-core';\nimport { VRMAnimation } from './VRMAnimation';\nimport { arrayChunk } from './utils/arrayChunk';\n\nconst MAT4_IDENTITY = /*@__PURE__*/ new THREE.Matrix4();\n\nconst _v3A = /*@__PURE__*/ new THREE.Vector3();\nconst _quatA = /*@__PURE__*/ new THREE.Quaternion();\nconst _quatB = /*@__PURE__*/ new THREE.Quaternion();\nconst _quatC = /*@__PURE__*/ new THREE.Quaternion();\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = /*@__PURE__*/ new Set(['1.0', '1.0-draft']);\n\nconst vrmExpressionPresetNameSet: Set<string> = /*@__PURE__*/ new Set(Object.values(VRMExpressionPresetName));\n\ninterface VRMAnimationLoaderPluginNodeMap {\n  humanoidIndexToName: Map<number, VRMHumanBoneName>;\n  expressionsIndexToName: Map<number, string>;\n  lookAtIndex: number | null;\n}\n\ntype VRMAnimationLoaderPluginWorldMatrixMap = Map<VRMHumanBoneName | 'hipsParent', THREE.Matrix4>;\n\n/**\n * A plugin of GLTFLoader that imports {@link VRMAnimation}s from a `VRMC_vrm_animation` extension and gltf animations.\n */\nexport class VRMAnimationLoaderPlugin implements GLTFLoaderPlugin {\n  public readonly parser: GLTFParser;\n\n  public constructor(parser: GLTFParser) {\n    this.parser = parser;\n  }\n\n  public get name(): string {\n    return 'VRMC_vrm_animation';\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    const defGltf = gltf.parser.json as GLTFSchema.IGLTF;\n    const defExtensionsUsed = defGltf.extensionsUsed;\n\n    if (defExtensionsUsed == null || defExtensionsUsed.indexOf(this.name) == -1) {\n      return;\n    }\n\n    const defExtension = defGltf.extensions?.[this.name] as VRMCVRMAnimation | undefined;\n\n    if (defExtension == null) {\n      return;\n    }\n\n    const specVersion = defExtension.specVersion;\n    if (specVersion == null) {\n      console.warn(\n        'VRMAnimationLoaderPlugin: specVersion of the VRMA is not defined. Consider updating the animation file. Assuming the spec version is 1.0.',\n      );\n    } else {\n      if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n        console.warn(`VRMAnimationLoaderPlugin: Unknown VRMC_vrm_animation spec version: ${specVersion}`);\n        return;\n      }\n      if (specVersion === '1.0-draft') {\n        console.warn(\n          'VRMAnimationLoaderPlugin: Using a draft spec version: 1.0-draft. Some behaviors may be different. Consider updating the animation file.',\n        );\n      }\n    }\n\n    const nodeMap = this._createNodeMap(defExtension);\n    const worldMatrixMap = await this._createBoneWorldMatrixMap(gltf, defExtension);\n\n    const hipsNode = defExtension.humanoid?.humanBones['hips']?.node;\n    const hips = hipsNode != null ? ((await gltf.parser.getDependency('node', hipsNode)) as THREE.Object3D) : null;\n\n    const restHipsPosition = new THREE.Vector3();\n    hips?.getWorldPosition(restHipsPosition);\n\n    // If the y component of the rest hips position is approximately zero or below,\n    // it is considered that the animation violates the VRM T-pose\n    if (restHipsPosition.y < 1e-3) {\n      console.warn(\n        'VRMAnimationLoaderPlugin: The loaded VRM Animation might violate the VRM T-pose (The y component of the rest hips position is approximately zero or below.)',\n      );\n    }\n\n    const clips = gltf.animations;\n    const animations: VRMAnimation[] = clips.map((clip, iAnimation) => {\n      const defAnimation = defGltf.animations![iAnimation];\n\n      const animation = this._parseAnimation(clip, defAnimation, nodeMap, worldMatrixMap);\n      animation.restHipsPosition = restHipsPosition;\n\n      return animation;\n    });\n\n    gltf.userData.vrmAnimations = animations;\n  }\n\n  private _createNodeMap(defExtension: VRMCVRMAnimation): VRMAnimationLoaderPluginNodeMap {\n    const humanoidIndexToName: Map<number, VRMHumanBoneName> = new Map();\n    const expressionsIndexToName: Map<number, string> = new Map();\n\n    // humanoid\n    const humanBones = defExtension.humanoid?.humanBones;\n\n    if (humanBones) {\n      Object.entries(humanBones).forEach(([name, bone]) => {\n        const node = bone?.node;\n        if (node != null) {\n          humanoidIndexToName.set(node, name as VRMHumanBoneName);\n        }\n      });\n    }\n\n    // expressions\n    const preset = defExtension.expressions?.preset;\n\n    if (preset) {\n      Object.entries(preset).forEach(([name, expression]) => {\n        const node = expression?.node;\n        if (node != null) {\n          expressionsIndexToName.set(node, name);\n        }\n      });\n    }\n\n    const custom = defExtension.expressions?.custom;\n\n    if (custom) {\n      Object.entries(custom).forEach(([name, expression]) => {\n        const { node } = expression;\n        expressionsIndexToName.set(node, name);\n      });\n    }\n\n    // lookAt\n    const lookAtIndex = defExtension.lookAt?.node ?? null;\n\n    return { humanoidIndexToName, expressionsIndexToName, lookAtIndex };\n  }\n\n  private async _createBoneWorldMatrixMap(\n    gltf: GLTF,\n    defExtension: VRMCVRMAnimation,\n  ): Promise<VRMAnimationLoaderPluginWorldMatrixMap> {\n    // update the entire hierarchy first\n    gltf.scene.updateWorldMatrix(false, true);\n\n    const threeNodes = (await gltf.parser.getDependencies('node')) as THREE.Object3D[];\n\n    const worldMatrixMap: VRMAnimationLoaderPluginWorldMatrixMap = new Map();\n\n    if (defExtension.humanoid == null) {\n      return worldMatrixMap;\n    }\n\n    for (const [boneName, humanBone] of Object.entries(defExtension.humanoid.humanBones)) {\n      const node = humanBone?.node;\n      if (node != null) {\n        const threeNode = threeNodes[node];\n        worldMatrixMap.set(boneName as VRMHumanBoneName, threeNode.matrixWorld);\n\n        if (boneName === 'hips') {\n          worldMatrixMap.set('hipsParent', threeNode.parent?.matrixWorld ?? MAT4_IDENTITY);\n        }\n      }\n    }\n\n    return worldMatrixMap;\n  }\n\n  private _parseAnimation(\n    animationClip: THREE.AnimationClip,\n    defAnimation: GLTFSchema.IAnimation,\n    nodeMap: VRMAnimationLoaderPluginNodeMap,\n    worldMatrixMap: VRMAnimationLoaderPluginWorldMatrixMap,\n  ): VRMAnimation {\n    const tracks = animationClip.tracks;\n    const defChannels = defAnimation.channels;\n\n    const result = new VRMAnimation();\n\n    result.duration = animationClip.duration;\n\n    defChannels.forEach((channel, iChannel) => {\n      const { node, path } = channel.target;\n      const origTrack = tracks[iChannel];\n\n      if (node == null) {\n        return;\n      }\n\n      // humanoid\n      const boneName = nodeMap.humanoidIndexToName.get(node);\n      if (boneName != null) {\n        let parentBoneName: VRMHumanBoneName | 'hipsParent' | null = VRMHumanBoneParentMap[boneName];\n        while (parentBoneName != null && worldMatrixMap.get(parentBoneName) == null) {\n          parentBoneName = VRMHumanBoneParentMap[parentBoneName];\n        }\n        if (parentBoneName == null) {\n          parentBoneName = 'hipsParent';\n        }\n\n        if (path === 'translation') {\n          if (boneName !== 'hips') {\n            console.warn(\n              `The loading animation contains a translation track for ${boneName}, which is not permitted in the VRMC_vrm_animation spec. ignoring the track`,\n            );\n          } else {\n            const hipsParentWorldMatrix = worldMatrixMap.get('hipsParent')!;\n\n            const trackValues = arrayChunk(origTrack.values, 3).flatMap((v) =>\n              _v3A.fromArray(v).applyMatrix4(hipsParentWorldMatrix).toArray(),\n            );\n\n            const track = origTrack.clone();\n            track.values = new Float32Array(trackValues);\n\n            result.humanoidTracks.translation.set(boneName, track);\n          }\n        } else if (path === 'rotation') {\n          // a  = p^-1 * a' * p * c\n          // a' = p * p^-1 * a' * p * c * c^-1 * p^-1\n          //    = p * a * c^-1 * p^-1\n\n          const worldMatrix = worldMatrixMap.get(boneName)!;\n          const parentWorldMatrix = worldMatrixMap.get(parentBoneName)!;\n\n          worldMatrix.decompose(_v3A, _quatA, _v3A);\n          _quatA.invert();\n\n          parentWorldMatrix.decompose(_v3A, _quatB, _v3A);\n\n          const trackValues = arrayChunk(origTrack.values, 4).flatMap((q) =>\n            _quatC\n              .fromArray(q as THREE.QuaternionTuple)\n              .premultiply(_quatB)\n              .multiply(_quatA)\n              .toArray(),\n          );\n\n          const track = origTrack.clone();\n          track.values = new Float32Array(trackValues);\n\n          result.humanoidTracks.rotation.set(boneName, track);\n        } else {\n          throw new Error(`Invalid path \"${path}\"`);\n        }\n        return;\n      }\n\n      // expressions\n      const expressionName = nodeMap.expressionsIndexToName.get(node);\n      if (expressionName != null) {\n        if (path === 'translation') {\n          const times = origTrack.times;\n          const values = new Float32Array(origTrack.values.length / 3);\n          for (let i = 0; i < values.length; i++) {\n            values[i] = origTrack.values[3 * i];\n          }\n\n          const newTrack = new THREE.NumberKeyframeTrack(`${expressionName}.weight`, times as any, values as any);\n\n          if (vrmExpressionPresetNameSet.has(expressionName)) {\n            result.expressionTracks.preset.set(expressionName as VRMExpressionPresetName, newTrack);\n          } else {\n            result.expressionTracks.custom.set(expressionName, newTrack);\n          }\n        } else {\n          throw new Error(`Invalid path \"${path}\"`);\n        }\n        return;\n      }\n\n      // lookAt\n      if (node === nodeMap.lookAtIndex) {\n        if (path === 'rotation') {\n          result.lookAtTrack = origTrack;\n        } else {\n          throw new Error(`Invalid path \"${path}\"`);\n        }\n      }\n    });\n\n    return result;\n  }\n}\n", "/**\n * ```js\n * arrayChunk( [ 1, 2, 3, 4, 5, 6 ], 2 )\n * // will be\n * [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ]\n * ```\n */\nexport function arrayChunk<T>(array: ArrayLike<T>, every: number): T[][] {\n  const N = array.length;\n\n  const ret: T[][] = [];\n\n  let current: T[] = [];\n  let remaining = 0;\n\n  for (let i = 0; i < N; i++) {\n    const el = array[i];\n\n    if (remaining <= 0) {\n      remaining = every;\n      current = [];\n      ret.push(current);\n    }\n\n    current.push(el);\n    remaining--;\n  }\n\n  return ret;\n}\n"],
  "mappings": "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",
  "names": ["__async", "_VRMExpressionMaterialColorBind", "_VRMExpressionTextureTransformBind", "_a", "_VRMExpressionLoaderPlugin", "_b", "_VRMFirstPerson", "_v3A", "_quatA", "_v3B", "_quatB", "_VRMLookAt", "VEC3_POSITIVE_Z", "_eulerA", "_quatC", "POSSIBLE_SPEC_VERSIONS"]
}
